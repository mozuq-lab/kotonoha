# TDDテストケース定義: TASK-0008 - SQLAlchemyモデル実装

## 生成情報
- **生成日時**: 2025-11-20
- **タスクID**: TASK-0008
- **タスク名**: SQLAlchemyモデル実装
- **テスト対象**: SQLAlchemyモデル（ベースクラス、AI変換履歴モデル、セッション管理）
- **要件定義書**: `docs/implements/kotonoha/TASK-0008/kotonoha-requirements.md`

## 開発言語・フレームワーク

### プログラミング言語 🔵
- **言語**: Python 3.10+
- **言語選択の理由**:
  - プロジェクトのバックエンドはFastAPI（Python）で構築されている
  - SQLAlchemy 2.x の非同期対応機能を活用できる
  - 型ヒント（Type Hints）により型安全性を確保できる
- **テストに適した機能**:
  - `async`/`await` による非同期テスト対応
  - 型ヒントによるコード補完とエラー検出
  - デコレータによるテストフィクスチャの柔軟な定義

### テストフレームワーク 🔵
- **テストフレームワーク**: pytest 8.3.5 + pytest-asyncio 0.25.2
- **フレームワーク選択の理由**:
  - Pythonのデファクトスタンダードなテストフレームワーク
  - `pytest-asyncio` により非同期テスト（`async def test_*`）が可能
  - フィクスチャ機能により効率的なテストセットアップ・クリーンアップ
  - `pytest-cov` により80%以上のカバレッジ目標（NFR-501）を達成可能
  - `pyproject.toml` で既に設定済み（line 16-22）
- **テスト実行環境**:
  - Docker Compose で PostgreSQL 15+ を起動
  - `.env.test` でテスト用データベース接続設定
  - CI/CD環境では GitHub Actions 等で自動テスト実行

## テストケース一覧

### カテゴリA: ベースモデルクラス（`backend/app/db/base_class.py`）

#### A-1. ベースモデルクラスの定義 🔵

- **テスト名**: ベースモデルクラスが正常に定義される
  - **何をテストするか**: `Base` クラスが `as_declarative()` デコレータで正しく定義されること
  - **期待される動作**: SQLAlchemy の宣言的基底クラスとして機能すること
- **入力値**: なし（クラス定義の検証）
  - **入力データの意味**: このテストは定義の検証であり、実行時の入力は不要
- **期待される結果**:
  - `Base` クラスが存在すること
  - `Base` クラスが `registry` 属性を持つこと（SQLAlchemy 2.x の要件）
  - **期待結果の理由**: すべてのモデルクラスがこの `Base` を継承するため、正しく定義される必要がある
- **テストの目的**: SQLAlchemy の宣言的基底クラスが正しく機能することを確認
  - **確認ポイント**: `Base` クラスの存在、`registry` 属性の有無
- 🔵 このテストケースは要件定義書（line 45-50）とSQLAlchemy 2.x公式ドキュメントに基づく

---

### カテゴリB: AI変換履歴モデル（`backend/app/models/ai_conversion_history.py`）

#### B-1. モデルインスタンスの正常作成（必須フィールドのみ） 🔵

- **テスト名**: 必須フィールドのみでAIConversionHistoryモデルのインスタンスを作成できる
  - **何をテストするか**: `input_text`, `converted_text`, `politeness_level` の3つの必須フィールドでモデルインスタンスが作成できること
  - **期待される動作**: インスタンス化が成功し、フィールド値が正しく設定されること
- **入力値**:
  - `input_text`: "水 ぬるく"
  - `converted_text`: "お水をぬるめでお願いします"
  - `politeness_level`: `PolitenessLevel.NORMAL`
  - **入力データの意味**: 実際のユースケースを想定した日本語テキスト（要件定義書 line 172-177参照）
- **期待される結果**:
  - インスタンスが正常に作成される
  - 各フィールドの値が入力値と一致する
  - `id` と `created_at` は未設定（DB保存時に自動生成）
  - **期待結果の理由**: 必須フィールドのみで基本的なモデルインスタンスを作成できる必要がある
- **テストの目的**: モデルの基本的なインスタンス化が正常に動作することを確認
  - **確認ポイント**: 必須フィールドの値が正しく設定されること
- 🔵 このテストケースは要件定義書（line 52-64, line 166-177）に基づく

#### B-2. モデルインスタンスの正常作成（全フィールド） 🔵

- **テスト名**: すべてのフィールドを指定してAIConversionHistoryモデルのインスタンスを作成できる
  - **何をテストするか**: オプションフィールド（`conversion_time_ms`, `user_session_id`）を含むすべてのフィールドでインスタンスが作成できること
  - **期待される動作**: すべてのフィールドが正しく設定されること
- **入力値**:
  - `input_text`: "ありがとう"
  - `converted_text`: "ありがとうございます"
  - `politeness_level`: `PolitenessLevel.POLITE`
  - `conversion_time_ms`: 100
  - `user_session_id`: `UUID("12345678-1234-5678-1234-567812345678")`
  - **入力データの意味**: オプションフィールドも含めた完全なデータセット
- **期待される結果**:
  - インスタンスが正常に作成される
  - すべてのフィールドの値が入力値と一致する
  - **期待結果の理由**: オプションフィールドも正しく設定できることを保証する
- **テストの目的**: オプションフィールドを含む完全なモデルインスタンス化を確認
  - **確認ポイント**: オプションフィールド（`conversion_time_ms`, `user_session_id`）が正しく設定されること
- 🔵 このテストケースは要件定義書（line 52-66, line 86-95）に基づく

#### B-3. NULL許可フィールドの省略 🔵

- **テスト名**: NULL許可フィールド（conversion_time_ms, user_session_id）を省略してもインスタンスを作成できる
  - **何をテストするか**: オプションフィールドを省略した場合、Noneとして設定されること
  - **期待される動作**: 必須フィールドのみでインスタンス化が成功し、オプションフィールドはNone
- **入力値**:
  - `input_text`: "こんにちは"
  - `converted_text`: "こんにちは"
  - `politeness_level`: `PolitenessLevel.CASUAL`
  - （`conversion_time_ms`, `user_session_id` は省略）
  - **入力データの意味**: 最小限の必須フィールドのみ指定（要件定義書 line 265-274参照）
- **期待される結果**:
  - インスタンスが正常に作成される
  - `conversion_time_ms` が None
  - `user_session_id` が None
  - **期待結果の理由**: オプションフィールドは省略可能であり、DB側でもNULL許可されている
- **テストの目的**: NULL許可フィールドの仕様が正しく実装されていることを確認
  - **確認ポイント**: オプションフィールドがNoneとして設定されること
- 🔵 このテストケースは要件定義書（line 265-274）とデータベーススキーマ（database-schema.sql）に基づく

#### B-4. PolitenessLevel Enumの全値テスト（casual） 🔵

- **テスト名**: PolitenessLevel.CASUALでインスタンスを作成できる
  - **何をテストするか**: Enum値 `CASUAL` が正しく使用できること
  - **期待される動作**: `politeness_level=PolitenessLevel.CASUAL` でインスタンス化が成功
- **入力値**:
  - `input_text`: "元気?"
  - `converted_text`: "元気?"
  - `politeness_level`: `PolitenessLevel.CASUAL`
  - **入力データの意味**: カジュアルな文体を表すEnum値
- **期待される結果**:
  - インスタンスが正常に作成される
  - `politeness_level` が `PolitenessLevel.CASUAL` として設定される
  - **期待結果の理由**: `CASUAL` はEnum定義の有効な値（要件定義書 line 57参照）
- **テストの目的**: Enum値 `CASUAL` が正しく動作することを確認
  - **確認ポイント**: Enum値の設定と取得が正しく行われること
- 🔵 このテストケースは要件定義書（line 57）とデータベーススキーマに基づく

#### B-5. PolitenessLevel Enumの全値テスト（normal） 🔵

- **テスト名**: PolitenessLevel.NORMALでインスタンスを作成できる
  - **何をテストするか**: Enum値 `NORMAL` が正しく使用できること
  - **期待される動作**: `politeness_level=PolitenessLevel.NORMAL` でインスタンス化が成功
- **入力値**:
  - `input_text`: "水ください"
  - `converted_text`: "お水をください"
  - `politeness_level`: `PolitenessLevel.NORMAL`
  - **入力データの意味**: 通常の丁寧さを表すEnum値
- **期待される結果**:
  - インスタンスが正常に作成される
  - `politeness_level` が `PolitenessLevel.NORMAL` として設定される
  - **期待結果の理由**: `NORMAL` はEnum定義の有効な値
- **テストの目的**: Enum値 `NORMAL` が正しく動作することを確認
  - **確認ポイント**: Enum値の設定と取得が正しく行われること
- 🔵 このテストケースは要件定義書（line 57）に基づく

#### B-6. PolitenessLevel Enumの全値テスト（polite） 🔵

- **テスト名**: PolitenessLevel.POLITEでインスタンスを作成できる
  - **何をテストするか**: Enum値 `POLITE` が正しく使用できること
  - **期待される動作**: `politeness_level=PolitenessLevel.POLITE` でインスタンス化が成功
- **入力値**:
  - `input_text`: "トイレ"
  - `converted_text`: "お手洗いに行きたいのですが"
  - `politeness_level`: `PolitenessLevel.POLITE`
  - **入力データの意味**: 丁寧な文体を表すEnum値
- **期待される結果**:
  - インスタンスが正常に作成される
  - `politeness_level` が `PolitenessLevel.POLITE` として設定される
  - **期待結果の理由**: `POLITE` はEnum定義の有効な値
- **テストの目的**: Enum値 `POLITE` が正しく動作することを確認
  - **確認ポイント**: Enum値の設定と取得が正しく行われること
- 🔵 このテストケースは要件定義書（line 57）に基づく

---

### カテゴリC: データベースCRUD操作（`backend/app/db/session.py`）

#### C-1. データベース接続テスト 🔵

- **テスト名**: 非同期セッションが正常に作成され、データベースに接続できる
  - **何をテストするか**: `async_session_maker` から非同期セッションを取得し、データベースに接続できること
  - **期待される動作**: `SELECT 1` クエリが正常に実行される
- **入力値**: なし（接続テストのみ）
  - **入力データの意味**: データベース接続の確立を確認するための最小クエリ
- **期待される結果**:
  - セッションが正常に作成される
  - `SELECT 1` クエリの結果が `1` である
  - セッションがクローズされる
  - **期待結果の理由**: データベース接続が正常に確立されていることを保証する
- **テストの目的**: データベースセッション管理が正しく機能することを確認
  - **確認ポイント**: 非同期セッションの作成、接続、クローズが正常に行われること
- 🔵 このテストケースは要件定義書（line 67-75, line 373-376）に基づく

#### C-2. レコードの作成（INSERT） 🔵

- **テスト名**: AIConversionHistoryレコードをデータベースに保存できる
  - **何をテストするか**: モデルインスタンスをデータベースに保存し、自動生成値（`id`, `created_at`）が設定されること
  - **期待される動作**: レコードがデータベースに保存され、自動生成されたIDとタイムスタンプが取得できる
- **入力値**:
  - `input_text`: "助けて"
  - `converted_text`: "助けてください"
  - `politeness_level`: `PolitenessLevel.NORMAL`
  - **入力データの意味**: データベースに保存する実際のデータ
- **期待される結果**:
  - `session.add()` と `await session.commit()` が成功する
  - `record.id` が自動生成される（Integerの正の値）
  - `record.created_at` が自動設定される（datetime型）
  - データベースに実際にレコードが保存される
  - **期待結果の理由**: SQLAlchemyのORMマッピングが正しく機能し、PostgreSQLのシーケンスとタイムスタンプが自動生成される
- **テストの目的**: データベースへのレコード作成機能を確認
  - **確認ポイント**: 自動生成フィールド（`id`, `created_at`）が正しく設定されること
- 🔵 このテストケースは要件定義書（line 180-188, line 379-382）に基づく

#### C-3. レコードの読み取り（SELECT） 🔵

- **テスト名**: 保存したAIConversionHistoryレコードをクエリで取得できる
  - **何をテストするか**: データベースに保存したレコードを `SELECT` クエリで取得し、保存した値と一致すること
  - **期待される動作**: 保存したデータと一致するレコードが取得できる
- **入力値**:
  - 事前に保存したレコード（`input_text="暑い"`, `converted_text="暑いです"`, `politeness_level=NORMAL`）
  - **入力データの意味**: データベースに事前保存したテストデータ
- **期待される結果**:
  - `SELECT` クエリでレコードが取得できる
  - 取得したレコードの `input_text`, `converted_text`, `politeness_level` が保存した値と一致する
  - `id` と `created_at` が設定されている
  - **期待結果の理由**: データベースからの読み取り操作が正しく機能することを保証する
- **テストの目的**: データベースからのレコード読み取り機能を確認
  - **確認ポイント**: 保存したデータが正確に取得できること
- 🔵 このテストケースは要件定義書（line 189-202, line 384-386）に基づく

#### C-4. レコードの絞り込み検索（WHERE句） 🔵

- **テスト名**: user_session_idで絞り込んでレコードを取得できる
  - **何をテストするか**: `WHERE` 句を使用して特定の `user_session_id` のレコードのみを取得できること
  - **期待される動作**: 指定したセッションIDのレコードのみが取得される
- **入力値**:
  - 事前に保存した2つのレコード:
    - レコード1: `user_session_id=UUID_A`, `input_text="テスト1"`
    - レコード2: `user_session_id=UUID_B`, `input_text="テスト2"`
  - 検索条件: `user_session_id=UUID_A`
  - **入力データの意味**: セッションIDによる絞り込み検索を確認するためのデータセット
- **期待される結果**:
  - `UUID_A` のレコードのみが取得される（1件）
  - 取得したレコードの `input_text` が "テスト1"
  - `UUID_B` のレコードは取得されない
  - **期待結果の理由**: インデックス（`idx_ai_conversion_session`）により高速な検索が可能（要件定義書 line 150参照）
- **テストの目的**: WHERE句による絞り込み検索が正しく機能することを確認
  - **確認ポイント**: 指定した条件のレコードのみが取得されること
- 🔵 このテストケースは要件定義書（line 189-202, line 150）に基づく

#### C-5. レコードのソート（ORDER BY） 🔵

- **テスト名**: created_atの降順でレコードを取得できる
  - **何をテストするか**: `ORDER BY created_at DESC` でレコードが新しい順に取得されること
  - **期待される動作**: 最新のレコードが先頭に並ぶ
- **入力値**:
  - 事前に保存した3つのレコード（時系列順に保存）:
    - レコード1: `input_text="古い1"` (最も古い)
    - レコード2: `input_text="古い2"`
    - レコード3: `input_text="新しい"` (最新)
  - **入力データの意味**: ソート機能を確認するための時系列データ
- **期待される結果**:
  - `ORDER BY created_at DESC` で取得したレコード順:
    1. `input_text="新しい"` (最新)
    2. `input_text="古い2"`
    3. `input_text="古い1"` (最も古い)
  - **期待結果の理由**: インデックス（`idx_ai_conversion_created_at`）により効率的なソートが可能（要件定義書 line 149参照）
- **テストの目的**: ORDER BY句によるソート機能を確認
  - **確認ポイント**: レコードが `created_at` の降順で正しく並ぶこと
- 🔵 このテストケースは要件定義書（line 189-202, line 149）に基づく

#### C-6. レコードの件数制限（LIMIT） 🔵

- **テスト名**: LIMIT句で取得件数を制限できる
  - **何をテストするか**: `LIMIT 10` で取得件数を制限できること
  - **期待される動作**: 指定した件数のレコードのみが取得される
- **入力値**:
  - 事前に保存した15件のレコード
  - 検索条件: `LIMIT 10`
  - **入力データの意味**: 件数制限機能を確認するための大量データ
- **期待される結果**:
  - 取得されるレコード数が10件
  - 最新の10件が取得される（`ORDER BY created_at DESC` と組み合わせ）
  - **期待結果の理由**: API応答時間を短縮し、パフォーマンスを確保する（NFR-002準拠）
- **テストの目的**: LIMIT句による件数制限が正しく機能することを確認
  - **確認ポイント**: 指定した件数のレコードのみが取得されること
- 🔵 このテストケースは要件定義書（line 189-202）に基づく

---

### カテゴリD: トランザクション管理・エラーハンドリング

#### D-1. トランザクション正常コミット 🔵

- **テスト名**: トランザクション内で複数のレコードを正常にコミットできる
  - **何をテストするか**: `async with session.begin()` でトランザクションを開始し、複数レコードを一括コミットできること
  - **期待される動作**: トランザクション内のすべてのレコードがデータベースに保存される
- **入力値**:
  - レコード1: `input_text="テスト1"`, `politeness_level=CASUAL`
  - レコード2: `input_text="テスト2"`, `politeness_level=NORMAL`
  - **入力データの意味**: トランザクション内で複数操作を行うためのデータセット
- **期待される結果**:
  - トランザクションが正常にコミットされる
  - 2件のレコードがデータベースに保存される
  - 各レコードに `id` と `created_at` が自動生成される
  - **期待結果の理由**: トランザクション管理により、複数操作の原子性を保証する
- **テストの目的**: トランザクションの正常コミット機能を確認
  - **確認ポイント**: トランザクション内のすべての操作が成功すること
- 🔵 このテストケースは要件定義書（line 253-262, line 388-391）に基づく

#### D-2. トランザクションロールバック 🔵

- **テスト名**: エラー発生時にトランザクションがロールバックされる
  - **何をテストするか**: トランザクション内でエラーが発生した場合、すべての操作がロールバックされること
  - **期待される動作**: エラー発生前の操作も含め、トランザクション内のすべての変更が破棄される
- **入力値**:
  - レコード1: `input_text="保存される前"`, `politeness_level=CASUAL` (正常なデータ)
  - レコード2: `input_text=None`, `politeness_level=NORMAL` (NOT NULL制約違反)
  - **入力データの意味**: トランザクション途中でエラーを発生させるためのデータ
- **期待される結果**:
  - レコード2の保存時に `IntegrityError` が発生
  - トランザクションが自動的にロールバックされる
  - レコード1もデータベースに保存されない（トランザクション全体が破棄）
  - データベースの状態が変更前の状態に戻る
  - **期待結果の理由**: トランザクションの原子性（Atomicity）により、一部の操作だけが保存されることを防ぐ（ACID特性）
- **テストの目的**: トランザクションのロールバック機能を確認
  - **確認ポイント**: エラー時にトランザクション内のすべての操作が破棄されること
- 🔵 このテストケースは要件定義書（line 234-251, line 388-391, NFR-304）に基づく

#### D-3. データベース接続エラー時のハンドリング 🟡

- **テスト名**: データベースが利用不可の場合、OperationalErrorが発生する
  - **何をテストするか**: データベースに接続できない状態でセッション作成を試みた場合、適切な例外が発生すること
  - **期待される動作**: `OperationalError` が発生し、エラーメッセージが適切に設定される
  - **エラー処理の重要性**: データベースダウン時にアプリケーションが適切にエラーを報告し、ユーザーに情報を提供する（NFR-304準拠）
- **入力値**: 不正なデータベースURL（例: `postgresql+asyncpg://invalid:invalid@localhost:9999/invalid`）
  - **不正な理由**: 存在しないホストまたはポートを指定
  - **実際の発生シナリオ**: PostgreSQLサーバーのダウン、ネットワーク障害、設定ミス
- **期待される結果**:
  - `OperationalError` または `TimeoutError` が発生
  - エラーメッセージに接続エラーの詳細が含まれる
  - セッションがクローズされる（リソースリーク防止）
  - **エラーメッセージの内容**: ユーザーに「データベースに接続できません」と通知
  - **システムの安全性**: エラー発生時もアプリケーションがクラッシュせず、適切なHTTP 503エラーを返す
- **テストの目的**: データベース接続エラー時の適切なエラーハンドリングを確認
  - **品質保証の観点**: NFR-304（データベースエラー時の適切なエラーハンドリング）を満たす
- 🟡 このテストケースは要件定義書（line 234-251, line 416-420）に基づくが、テスト実装方法は推測

#### D-4. NOT NULL制約違反エラー 🔵

- **テスト名**: 必須フィールドがNoneの場合、IntegrityErrorが発生する
  - **何をテストするか**: NOT NULL制約のあるフィールドに None を設定してコミットした場合、データベース側でエラーが発生すること
  - **エラーケースの概要**: 必須フィールドの入力漏れ、バリデーション不備
  - **エラー処理の重要性**: データ整合性を保ち、不正なデータの保存を防ぐ
- **入力値**:
  - `input_text`: None (NOT NULL制約違反)
  - `converted_text`: "テスト"
  - `politeness_level`: `PolitenessLevel.NORMAL`
  - **不正な理由**: `input_text` は NOT NULL 制約があり、None は許可されない（要件定義書 line 54, line 146参照）
  - **実際の発生シナリオ**: APIリクエストでフィールドが欠落、バリデーション処理の不備
- **期待される結果**:
  - `await session.commit()` 時に `IntegrityError` が発生
  - エラーメッセージに "null value in column "input_text"" などの詳細が含まれる
  - レコードは保存されない
  - **エラーメッセージの内容**: 開発者向けに制約違反の詳細を提供
  - **システムの安全性**: 不正なデータが保存されず、データベース整合性が保たれる
- **テストの目的**: NOT NULL制約が正しく機能することを確認
  - **品質保証の観点**: データベース制約によりデータ品質を保証する
- 🔵 このテストケースは要件定義書（line 293-307, line 421-426）に基づく

---

### カテゴリE: 異常系・境界値テスト

#### E-1. 不正なEnum値の設定（Pythonレベルバリデーション） 🟡

- **テスト名**: 存在しないpoliteness_level値を設定した場合、ValueErrorが発生する
  - **何をテストするか**: Enum型に定義されていない値を設定した場合、Pythonレベルでエラーが発生すること
  - **エラーケースの概要**: 無効なEnum値の指定
  - **エラー処理の重要性**: データベースに不正な値が保存される前にPythonレベルで検出する
- **入力値**:
  - `input_text`: "テスト"
  - `converted_text`: "テストです"
  - `politeness_level`: "super_polite" (Enumに存在しない文字列)
  - **不正な理由**: `PolitenessLevel` Enum には 'casual', 'normal', 'polite' のみが定義されている（要件定義書 line 57参照）
  - **実際の発生シナリオ**: APIリクエストで不正な値を送信、フロントエンドのバグ
- **期待される結果**:
  - `ValueError` または `AttributeError` が発生
  - エラーメッセージに "is not a valid PolitenessLevel" などの詳細が含まれる
  - **エラーメッセージの内容**: 開発者向けに有効な値の一覧を提示
  - **システムの安全性**: 不正な値がデータベースに保存される前にブロックされる
- **テストの目的**: Enum型バリデーションが正しく機能することを確認
  - **品質保証の観点**: Pythonの型安全性により早期にエラーを検出する
- 🟡 このテストケースは要件定義書（line 276-290）に基づくが、Enum実装方法は推測

#### E-2. 空文字列の入力（境界値） 🔵

- **テスト名**: input_textに空文字列を設定してもレコードを作成できる
  - **何をテストするか**: 空文字列（""）がNOT NULL制約を満たすこと
  - **境界値の意味**: 空文字列は技術的には NULL ではないため、保存可能であるべき
  - **境界値での動作保証**: 空文字列と NULL の違いを正しく処理する
- **入力値**:
  - `input_text`: ""（空文字列）
  - `converted_text`: ""（空文字列）
  - `politeness_level`: `PolitenessLevel.CASUAL`
  - **境界値選択の根拠**: 空文字列は有効な文字列値であり、NULL とは異なる
  - **実際の使用場面**: ユーザーが何も入力せずに送信した場合（実際にはフロントエンドでバリデーションすべき）
- **期待される結果**:
  - レコードが正常に作成される
  - `input_text` と `converted_text` が空文字列として保存される
  - NOT NULL制約違反エラーは発生しない
  - **境界での正確性**: 空文字列が正しく保存され、取得時も空文字列として返される
  - **一貫した動作**: PostgreSQL の Text 型は空文字列を正しく保存する
- **テストの目的**: 空文字列がNOT NULL制約を満たすことを確認
  - **堅牢性の確認**: 境界値（空文字列）でもシステムが正常動作すること
- 🔵 このテストケースはデータベース仕様とPostgreSQL動作に基づく

#### E-3. 非常に長いテキストの入力（境界値） 🟡

- **テスト名**: 非常に長いテキスト（10,000文字）を設定してもレコードを作成できる
  - **何をテストするか**: PostgreSQL の Text 型が長いテキストを正しく保存できること
  - **境界値の意味**: Text 型は理論上無制限だが、実用的な長さでの動作を確認
  - **境界での動作保証**: 大量のテキストデータでもパフォーマンス劣化がないこと
- **入力値**:
  - `input_text`: "あ" × 10,000（10,000文字の文字列）
  - `converted_text`: "あ" × 10,000
  - `politeness_level`: `PolitenessLevel.NORMAL`
  - **境界値選択の根拠**: 一般的な使用では数十～数百文字だが、極端な場合を想定
  - **実際の使用場面**: ユーザーが長文を入力した場合、悪意のある大量データ送信
- **期待される結果**:
  - レコードが正常に作成される
  - `input_text` と `converted_text` が完全に保存される（データ欠損なし）
  - パフォーマンスが著しく劣化しない（1秒以内に保存完了）
  - **境界での正確性**: 長いテキストが切り捨てられることなく保存される
  - **一貫した動作**: 取得時も10,000文字が正しく返される
- **テストの目的**: PostgreSQL Text型の長文保存能力を確認
  - **堅牢性の確認**: 極端な長さのデータでもシステムが安定動作すること
- 🟡 このテストケースは妥当な推測（実際の使用では想定外だが、テストとして有用）

#### E-4. conversion_time_msの境界値（0ミリ秒） 🔵

- **テスト名**: conversion_time_ms=0を設定してもレコードを作成できる
  - **何をテストするか**: 0ミリ秒（瞬時の変換）が有効な値として保存できること
  - **境界値の意味**: 処理時間の最小値（0ミリ秒）
  - **境界値での動作保証**: 0が NULL として扱われないこと
- **入力値**:
  - `input_text`: "テスト"
  - `converted_text`: "テスト"
  - `politeness_level`: `PolitenessLevel.CASUAL`
  - `conversion_time_ms`: 0
  - **境界値選択の根拠**: 処理時間の最小値として0は有効
  - **実際の使用場面**: キャッシュヒット時の即座の変換、テスト環境での高速処理
- **期待される結果**:
  - レコードが正常に作成される
  - `conversion_time_ms` が 0 として保存される（NULL ではない）
  - **境界での正確性**: 0 が正しく保存され、取得時も 0 として返される
  - **一貫した動作**: 0 と NULL が区別されること
- **テストの目的**: 0ミリ秒が有効な値として扱われることを確認
  - **堅牢性の確認**: 境界値（0）でもシステムが正常動作すること
- 🔵 このテストケースは要件定義書（line 59）に基づく

#### E-5. conversion_time_msの境界値（非常に大きい値） 🟡

- **テスト名**: conversion_time_ms=999999（非常に大きい値）を設定してもレコードを作成できる
  - **何をテストするか**: PostgreSQL の Integer 型の範囲内で大きな値を保存できること
  - **境界値の意味**: 処理時間が異常に長い場合の最大値
  - **境界値での動作保証**: Integer型の上限（2,147,483,647）に近い値でも正しく動作すること
- **入力値**:
  - `input_text`: "テスト"
  - `converted_text`: "テスト"
  - `politeness_level`: `PolitenessLevel.NORMAL`
  - `conversion_time_ms`: 999999（999秒 = 約16分）
  - **境界値選択の根拠**: AI変換の応答時間目標は3秒以内だが、タイムアウト等で非常に長くなる可能性
  - **実際の使用場面**: AI APIのタイムアウト、ネットワーク遅延、サーバー高負荷時
- **期待される結果**:
  - レコードが正常に作成される
  - `conversion_time_ms` が 999999 として正確に保存される
  - **境界での正確性**: 大きな値が切り捨てられることなく保存される
  - **一貫した動作**: 取得時も 999999 が正しく返される
- **テストの目的**: Integer型の範囲内で大きな値が正しく保存されることを確認
  - **堅牢性の確認**: 異常な処理時間でもシステムが安定動作すること
- 🟡 このテストケースは妥当な推測（実際の運用では想定外だが、テストとして有用）

#### E-6. conversion_time_msの負の値（異常値） 🟡

- **テスト名**: conversion_time_ms=-1（負の値）を設定した場合の動作を確認
  - **何をテストするか**: 負の処理時間（論理的に不正な値）を設定した場合の動作
  - **エラーケースの概要**: 無効なデータの入力
  - **エラー処理の重要性**: データの論理的整合性を保つ
- **入力値**:
  - `input_text`: "テスト"
  - `converted_text`: "テスト"
  - `politeness_level`: `PolitenessLevel.NORMAL`
  - `conversion_time_ms`: -1
  - **不正な理由**: 処理時間は0以上であるべき（負の時間は存在しない）
  - **実際の発生シナリオ**: バグによる不正な値の設定、計算エラー
- **期待される結果**:
  - 現在のスキーマでは CHECK 制約がないため、レコードが保存される可能性がある
  - または、アプリケーションレベルでバリデーションエラーを発生させる
  - **エラーメッセージの内容**: "処理時間は0以上である必要があります"
  - **システムの安全性**: 将来的にはCHECK制約（`conversion_time_ms >= 0`）を追加すべき
- **テストの目的**: 負の値に対する現在の動作を確認し、将来の改善点を特定
  - **品質保証の観点**: データの論理的整合性チェックの必要性を明確にする
- 🟡 このテストケースは妥当な推測（現在のスキーマには制約がないため、動作は実装依存）

---

## テストケース実装時の日本語コメント指針

### テストケース開始時のコメント

すべてのテストケースの冒頭に、以下の日本語コメントを記載します：

```python
# 【テスト目的】: AIConversionHistoryモデルの基本的なインスタンス化機能を確認する
# 【テスト内容】: 必須フィールド（input_text, converted_text, politeness_level）のみでインスタンスを作成
# 【期待される動作】: インスタンスが正常に作成され、各フィールドの値が正しく設定される
# 🔵 この内容は要件定義書（line 166-177）に基づく
```

### Given（準備フェーズ）のコメント

```python
# 【テストデータ準備】: 実際のユースケースを想定した日本語テキストを用意
# 【初期条件設定】: データベーステーブルが存在し、セッションが利用可能な状態
# 【前提条件確認】: PostgreSQLサーバーが起動していること
```

### When（実行フェーズ）のコメント

```python
# 【実際の処理実行】: AIConversionHistoryモデルのインスタンスを作成
# 【処理内容】: 必須フィールドを指定してコンストラクタを呼び出す
# 【実行タイミング】: テストデータ準備完了後、即座にインスタンス化を実行
```

### Then（検証フェーズ）のコメント

```python
# 【結果検証】: インスタンスが正常に作成されたことを確認
# 【期待値確認】: 各フィールドの値が入力値と一致することを検証
# 【品質保証】: モデルの基本機能が正しく実装されていることを保証し、データベース保存の基盤を確立
```

### 各expectステートメントのコメント

```python
# 【検証項目】: input_textフィールドの値が正しく設定されているか
# 🔵 要件定義書（line 54）に基づくNOT NULL制約フィールドの検証
assert record.input_text == "水 ぬるく"

# 【検証項目】: politeness_levelがEnum値として正しく設定されているか
# 🔵 要件定義書（line 57）に基づくEnum制約の検証
assert record.politeness_level == PolitenessLevel.NORMAL

# 【検証項目】: conversion_time_msがNoneとして設定されているか（NULL許可フィールド）
# 🔵 要件定義書（line 59, line 265-274）に基づくNULL許可フィールドの検証
assert record.conversion_time_ms is None
```

### セットアップ・クリーンアップのコメント

```python
@pytest.fixture
async def db_session():
    # 【テスト前準備】: 各テストケース実行前にクリーンなデータベースセッションを作成
    # 【環境初期化】: テスト用データベースに接続し、トランザクションを開始
    async with async_session_maker() as session:
        yield session
        # 【テスト後処理】: テスト実行後にトランザクションをロールバックし、データベースをクリーンな状態に復元
        # 【状態復元】: 次のテストに影響しないよう、すべての変更を破棄
        await session.rollback()
```

---

## テストファイル構成 🔵

### 実装予定のテストファイル

1. **`backend/tests/test_models.py`**
   - カテゴリB（モデルインスタンス化）のテストケース
   - カテゴリC（CRUD操作）のテストケース
   - カテゴリD（トランザクション管理）のテストケース
   - カテゴリE（異常系・境界値）のテストケース

2. **`backend/tests/test_db_connection.py`**
   - カテゴリC-1（データベース接続テスト）
   - カテゴリD-3（接続エラーハンドリング）

3. **`backend/tests/test_error_handling.py`**
   - カテゴリD（エラーハンドリング）のテストケース
   - カテゴリE（異常系）のテストケース

4. **`backend/tests/conftest.py`**
   - pytest設定
   - テスト用データベースセッションフィクスチャ
   - テスト用環境変数設定

---

## テストカバレッジ目標 🔵

### カバレッジ基準（pyproject.toml準拠）
- **全体カバレッジ**: 80%以上（NFR-501）
- **モデル層カバレッジ**: 90%以上（NFR-502）
  - `backend/app/models/ai_conversion_history.py`
  - `backend/app/db/base_class.py`
  - `backend/app/db/session.py`

### カバレッジ測定コマンド
```bash
pytest --cov=app --cov-report=html --cov-report=term-missing
```

### カバレッジレポート確認
- **HTML形式**: `htmlcov/index.html` をブラウザで開く
- **ターミナル形式**: テスト実行時に自動表示

---

## 品質判定

### テストケースの網羅性 ✅
- **正常系**: 8ケース（カテゴリB, C-1～C-6, D-1）
- **異常系**: 4ケース（D-2, D-3, D-4, E-1）
- **境界値**: 5ケース（E-2～E-6）
- **合計**: 17ケース

### 期待値定義の明確性 ✅
- すべてのテストケースで期待される結果が具体的に定義されている
- 期待結果の理由が明記されている
- 検証ポイントが明確

### 技術選択の確実性 ✅
- Python 3.10+ + pytest + pytest-asyncio（既存設定準拠）
- SQLAlchemy 2.x の非同期対応
- PostgreSQL 15+ の機能を活用

### 実装可能性 ✅
- すべてのテストケースが現在の技術スタックで実現可能
- 既存のpytest設定（pyproject.toml）に準拠
- テストフィクスチャ設計が明確

### 総合判定: ✅ 高品質
テストケースは高品質であり、TDD開発のRedフェーズ（失敗テスト作成）を開始する準備が整っています。

---

## 次のステップ

次のお勧めステップ: `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

Redフェーズでは、以下のテストファイルを作成します：
1. `backend/tests/conftest.py` - テスト用フィクスチャ設定
2. `backend/tests/test_models.py` - モデル層のテストケース
3. `backend/tests/test_db_connection.py` - データベース接続テスト
4. `backend/tests/test_error_handling.py` - エラーハンドリングテスト

すべてのテストは最初「失敗」する状態で作成され、次のGreenフェーズで実装を行います。

---

## 更新履歴
- **2025-11-20**: 初回作成（TDDテストケース洗い出しフェーズ - TASK-0008）
