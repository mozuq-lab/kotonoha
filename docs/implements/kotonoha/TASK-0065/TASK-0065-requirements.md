# TASK-0065: お気に入りHiveモデル・リポジトリ実装 - TDD要件定義書

## タスク概要

**タスクID**: TASK-0065
**タスク名**: お気に入りHiveモデル・リポジトリ実装
**タスクタイプ**: TDD
**推定工数**: 8時間
**関連要件**: REQ-701, REQ-703, NFR-101
**依存タスク**: TASK-0054 (Hive初期化)

### 実装目的

発話困難な方が頻繁に使用する文章をお気に入りとして登録・管理し、ワンタップで素早くアクセスできるようにするため、お気に入りデータのローカル永続化機能を実装する。

### 実装スコープ

1. FavoriteItem Hive モデル定義（TypeAdapter含む）
2. FavoriteRepository 作成（CRUD操作）
3. 並び順（displayOrder）の管理機能
4. 履歴・定型文からのお気に入り登録機能
5. ローカルストレージのみに保存（オフラインファースト設計）

### 完了条件

- お気に入りがHiveに正しく保存される
- アプリ再起動後もお気に入りデータが保持される
- 並び順（displayOrder）が正しく保存・反映される
- 履歴・定型文からお気に入りへの登録が可能
- すべてのテストケースが成功する（カバレッジ80%以上）

---

## 機能要件（Functional Requirements）

### FR-065-001: FavoriteItem Hiveモデル定義 🔵

**要件**: システムはお気に入りデータを永続化するためのHiveモデルを提供しなければならない

**詳細**:
- `@HiveType(typeId: 2)` として登録（typeId 0: HistoryItem, 1: 予約済み）
- 以下のフィールドを持つ:
  - `id`: String (UUID形式、@HiveField(0))
  - `content`: String (お気に入り登録したテキスト、@HiveField(1))
  - `createdAt`: DateTime (お気に入り登録日時、@HiveField(2))
  - `displayOrder`: int (並び順、@HiveField(3))
- `HiveObject` を継承
- `copyWith()` メソッドを実装（不変オブジェクトパターン）
- `==` 演算子と `hashCode` を実装（idベースの等価性比較）
- `toString()` メソッドを実装（デバッグ用）

**根拠**:
- REQ-701（お気に入り登録機能）
- REQ-703（並び順変更機能）
- NFR-101（ローカルストレージ優先）
- interfaces.dart の Favorite エンティティ定義

**信頼性レベル**: 🔵 青信号（要件定義書・設計文書・既存実装パターンに基づく）

---

### FR-065-002: FavoriteRepository基本CRUD操作 🔵

**要件**: システムはお気に入りの作成・読み込み・更新・削除操作を提供しなければならない

**詳細**:
- `save(FavoriteItem favorite)`: お気に入りを保存（新規追加・更新両対応）
- `loadAll()`: 全お気に入りを取得（displayOrder昇順でソート）
- `getById(String id)`: IDで特定のお気に入りを取得
- `delete(String id)`: IDでお気に入りを削除
- `deleteAll()`: 全お気に入りを削除
- すべてのメソッドは非同期（`Future<T>`）

**根拠**:
- REQ-701（お気に入り登録・一覧表示）
- REQ-704（お気に入り削除）
- HistoryRepository の実装パターンを踏襲

**信頼性レベル**: 🔵 青信号（既存RepositoryパターンとEARS要件に基づく）

---

### FR-065-003: 並び順（displayOrder）管理機能 🔵

**要件**: システムはお気に入りの表示順序をユーザーがカスタマイズできる機能を提供しなければならない

**詳細**:
- `updateDisplayOrder(String id, int newOrder)`: 特定のお気に入りの並び順を変更
- `reorderFavorites(List<String> orderedIds)`: 複数のお気に入りの並び順を一括更新
- `loadAll()` は常に displayOrder 昇順でソートして返す
- 並び順の値は 0 以上の整数
- 新規追加時のデフォルト displayOrder は既存の最大値+1

**根拠**:
- REQ-703（並び順変更機能）
- interfaces.dart の Favorite.displayOrder フィールド

**信頼性レベル**: 🔵 青信号（要件定義書とインターフェース定義に基づく）

---

### FR-065-004: お気に入り重複チェック 🟡

**要件**: システムは同一内容のお気に入り重複登録を防止する機能を提供しなければならない

**詳細**:
- `isDuplicate(String content)`: 同じcontentのお気に入りが既に存在するかチェック
- `save()` 実行時に重複チェックを行い、重複時は既存のものを返す（エラーにしない）
- 重複判定は `content` の完全一致で行う

**根拠**:
- ユーザビリティ向上（同じ文章を複数回登録することを防ぐ）
- NFR-201（操作の簡潔性）

**信頼性レベル**: 🟡 黄信号（要件定義書から妥当な推測）

---

### FR-065-005: 履歴からお気に入りへの登録 🔵

**要件**: システムは履歴アイテムをお気に入りとして登録する機能を提供しなければならない

**詳細**:
- `saveFromHistory(HistoryItem history)`: 履歴からお気に入りを作成
- 履歴の `content` をお気に入りの `content` として使用
- 新しいUUIDを生成（履歴のIDとは別）
- createdAt は現在時刻を設定
- displayOrder は自動採番（最大値+1）

**根拠**:
- REQ-701（定型文または履歴をお気に入り登録）
- REQ-4002（履歴からお気に入りへのワンタップ移動、オプション要件）
- dataflow.md の履歴→お気に入りフロー

**信頼性レベル**: 🔵 青信号（要件定義書に明記）

---

### FR-065-006: 定型文からお気に入りへの登録 🔵

**要件**: システムは定型文をお気に入りとして登録する機能を提供しなければならない

**詳細**:
- `saveFromPreset(PresetPhrase preset)`: 定型文からお気に入りを作成
- 定型文の `content` をお気に入りの `content` として使用
- 新しいUUIDを生成（定型文のIDとは別）
- createdAt は現在時刻を設定
- displayOrder は自動採番（最大値+1）

**根拠**:
- REQ-701（定型文または履歴をお気に入り登録）
- REQ-105（お気に入り定型文の優先表示）

**信頼性レベル**: 🔵 青信号（要件定義書に明記）

---

## 非機能要件（Non-Functional Requirements）

### NFR-065-001: データ永続性保証 🔵

**要件**: システムはアプリ終了・再起動後もお気に入りデータを保持しなければならない

**詳細**:
- Hive を使用したローカルストレージ永続化
- アプリ強制終了後もデータ損失なし
- OS再起動後もデータ保持

**根拠**:
- NFR-101（ローカルストレージ優先）
- REQ-5003（永続化機構の実装）

**信頼性レベル**: 🔵 青信号（アーキテクチャ設計に基づく）

---

### NFR-065-002: お気に入り読み込みパフォーマンス 🟡

**要件**: システムはお気に入り一覧の読み込みを500ms以内に完了しなければならない

**詳細**:
- `loadAll()` の実行時間: 100件のお気に入りで500ms以内
- ソート処理を含めた総時間
- UI ブロックを避けるため非同期処理で実装

**根拠**:
- NFR-004（定型文一覧表示1秒以内、お気に入りはより頻繁にアクセスされるため高速化）
- NFR-201（3タップ以内の操作完了）

**信頼性レベル**: 🟡 黄信号（既存パフォーマンス要件から類推）

---

### NFR-065-003: データ整合性保証 🔵

**要件**: システムは並び順変更時にデータ不整合が発生しないことを保証しなければならない

**詳細**:
- displayOrder の値は常に 0 以上の整数
- 並び順の一括更新時はトランザクション的に処理（すべて成功またはすべて失敗）
- 削除時に displayOrder の空き番号が発生してもよい（詰め直し不要）

**根拠**:
- NFR-304（データベースエラー時のエラーハンドリング）
- REQ-5003（永続化機構の信頼性）

**信頼性レベル**: 🔵 青信号（データ整合性は基本要件）

---

### NFR-065-004: テストカバレッジ 🔵

**要件**: システムはFavoriteRepository のテストカバレッジ90%以上を達成しなければならない

**詳細**:
- 単体テスト（unit test）ですべてのCRUD操作を網羅
- 境界値テスト（0件、1件、多数件）
- エラーハンドリングテスト
- 並び順管理のテスト

**根拠**:
- NFR-502（ビジネスロジック90%以上のカバレッジ）
- tech-stack.md のテスト戦略

**信頼性レベル**: 🔵 青信号（プロジェクト品質基準）

---

### NFR-065-005: プライバシー保護 🔵

**要件**: システムはお気に入りデータを端末内のみに保存し、外部送信しないことを保証しなければならない

**詳細**:
- Hive によるローカルストレージのみ使用
- クラウド同期なし
- ネットワーク通信なし
- ユーザーが任意にデータ削除可能

**根拠**:
- NFR-101（ローカルストレージ優先）
- NFR-103（任意削除機能）
- REQ-5004（単一端末完結）

**信頼性レベル**: 🔵 青信号（アーキテクチャ設計の根幹）

---

## エッジケース・境界値（Edge Cases）

### EDGE-065-001: お気に入り0件の状態 🟡

**シナリオ**: お気に入りが1件も登録されていない状態で `loadAll()` を実行

**期待動作**:
- 空のリスト `[]` を返す
- エラーを投げない
- UI側で「お気に入りがありません」メッセージを表示

**根拠**:
- EDGE-104（お気に入り0件の状態）
- NFR-204（分かりやすいエラーメッセージ）

**信頼性レベル**: 🟡 黄信号（要件定義書から推測）

---

### EDGE-065-002: 存在しないIDで削除 🔵

**シナリオ**: 存在しないIDで `delete(id)` を実行

**期待動作**:
- 例外を投げない（silent fail）
- HistoryRepository の delete() と同じ挙動

**根拠**:
- HistoryRepository の実装パターン（EDGE-006）
- NFR-301（基本機能の継続性）

**信頼性レベル**: 🔵 青信号（既存実装パターンを踏襲）

---

### EDGE-065-003: 存在しないIDで取得 🔵

**シナリオ**: 存在しないIDで `getById(id)` を実行

**期待動作**:
- `null` を返す
- 例外を投げない
- HistoryRepository の getById() と同じ挙動

**根拠**:
- HistoryRepository の実装パターン（FR-062-007）
- Dart の nullable 型安全性

**信頼性レベル**: 🔵 青信号（既存実装パターンを踏襲）

---

### EDGE-065-004: 同一IDで複数回保存 🔵

**シナリオ**: 同じIDのお気に入りを複数回 `save()` で保存

**期待動作**:
- 最後の保存内容で上書き更新
- 重複エラーを投げない
- displayOrder は変更されない（明示的に変更しない限り）

**根拠**:
- HistoryRepository の save() パターン（上書き更新）
- Hive の `put()` メソッドの仕様

**信頼性レベル**: 🔵 青信号（Hive の標準動作）

---

### EDGE-065-005: displayOrder の重複 🟡

**シナリオ**: 複数のお気に入りが同じ displayOrder 値を持つ

**期待動作**:
- ソート時は displayOrder が同じ場合、createdAt の降順（新しい順）で二次ソート
- エラーを投げない
- ユーザーが並び順を変更すれば自然に解消される

**根拠**:
- ユーザビリティ（エラーで操作を妨げない）
- NFR-304（適切なエラーハンドリング）

**信頼性レベル**: 🟡 黄信号（実装判断による妥当な推測）

---

### EDGE-065-006: 非常に長いcontent（1000文字超） 🟡

**シナリオ**: 1000文字を超えるテキストをお気に入り登録

**期待動作**:
- そのまま保存を許可（上限制限なし）
- Hive は文字列長の制限なし
- UI側で表示時に省略表示（例: 最初の100文字 + "..."）

**根拠**:
- EDGE-101（入力欄1000文字制限はあるが、お気に入りは制限なし）
- Hive のデータ容量制限は実質的に問題にならない

**信頼性レベル**: 🟡 黄信号（実装判断による推測）

---

### EDGE-065-007: 空文字列のcontent 🟡

**シナリオ**: `content` が空文字列（""）のお気に入りを保存

**期待動作**:
- 保存自体は成功する（エラーにしない）
- UI側でバリデーションを推奨（空文字列は登録させない）
- Repository層ではバリデーションしない（関心の分離）

**根拠**:
- Repository は永続化のみを責務とする（Clean Architecture）
- UI/ビジネスロジック層でバリデーション

**信頼性レベル**: 🟡 黄信号（アーキテクチャ判断による推測）

---

### EDGE-065-008: displayOrder の負の値 🟡

**シナリオ**: displayOrder に負の値（-1など）を設定

**期待動作**:
- 保存自体は成功する
- ソート時は負の値も含めて昇順ソート（-1, 0, 1, 2, ...）
- UI側で displayOrder は 0 以上のみ設定することを推奨

**根拠**:
- Repository は永続化のみを責務とする
- 柔軟性を持たせる（将来的に特殊用途で負の値を使う可能性）

**信頼性レベル**: 🟡 黄信号（実装判断による推測）

---

### EDGE-065-009: 履歴削除後もお気に入りは保持 🔵

**シナリオ**: 履歴からお気に入り登録後、元の履歴を削除

**期待動作**:
- お気に入りは削除されず保持される
- お気に入りと履歴は独立したエンティティ
- お気に入りのID ≠ 履歴のID

**根拠**:
- REQ-701（履歴をお気に入り登録）
- データ独立性の原則（履歴とお気に入りは別テーブル）

**信頼性レベル**: 🔵 青信号（データモデル設計の基本）

---

### EDGE-065-010: ストレージ容量不足 🟡

**シナリオ**: 端末のストレージ容量が不足している状態で `save()` を実行

**期待動作**:
- Hive が例外を投げる（HiveError など）
- Repository は例外をキャッチせず、そのまま上位層に伝播
- 上位層（ViewModel/UI）でエラーハンドリング

**根拠**:
- EDGE-003（ストレージ容量不足時の処理）
- NFR-304（適切なエラーハンドリング）

**信頼性レベル**: 🟡 黄信号（要件定義書から推測）

---

## 受け入れ基準（Acceptance Criteria）

### AC-065-001: お気に入り保存・読み込み 🔵

**Given**: FavoriteRepository が初期化されている
**When**: 新しいお気に入りを `save()` で保存し、`loadAll()` で取得する
**Then**:
- 保存したお気に入りが正しく取得できる
- id, content, createdAt, displayOrder が一致する

**テスト方法**: Unit Test（`test/features/favorite/data/favorite_repository_test.dart`）

**信頼性レベル**: 🔵 青信号（基本CRUD操作）

---

### AC-065-002: お気に入り削除 🔵

**Given**: お気に入りが複数件保存されている
**When**: 特定のIDで `delete(id)` を実行する
**Then**:
- 該当のお気に入りが削除される
- 他のお気に入りは影響を受けない
- `loadAll()` で該当IDのお気に入りが含まれない

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（基本CRUD操作）

---

### AC-065-003: 全お気に入り削除 🔵

**Given**: お気に入りが複数件保存されている
**When**: `deleteAll()` を実行する
**Then**:
- すべてのお気に入りが削除される
- `loadAll()` が空リストを返す

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（基本CRUD操作）

---

### AC-065-004: 並び順でソート 🔵

**Given**: displayOrder が異なる複数のお気に入りが保存されている
**When**: `loadAll()` を実行する
**Then**:
- displayOrder の昇順でソートされたリストが返る
- displayOrder: 0, 1, 2, 3, ... の順

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（REQ-703に基づく）

---

### AC-065-005: 並び順の更新 🔵

**Given**: displayOrder が 5 のお気に入りが存在する
**When**: `updateDisplayOrder(id, 10)` を実行する
**Then**:
- 該当お気に入りの displayOrder が 10 に更新される
- `getById(id)` で取得すると displayOrder == 10

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（REQ-703に基づく）

---

### AC-065-006: 並び順の一括更新 🔵

**Given**: 3件のお気に入り（ID: "a", "b", "c"）が存在する
**When**: `reorderFavorites(["c", "a", "b"])` を実行する
**Then**:
- "c" の displayOrder が 0
- "a" の displayOrder が 1
- "b" の displayOrder が 2
- `loadAll()` で ["c", "a", "b"] の順で返る

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（REQ-703に基づく）

---

### AC-065-007: 履歴からお気に入り登録 🔵

**Given**: HistoryItem が存在する
**When**: `saveFromHistory(history)` を実行する
**Then**:
- 新しいお気に入りが作成される
- お気に入りの content == 履歴の content
- お気に入りの id ≠ 履歴の id（新しいUUID）
- displayOrder は自動採番される

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（REQ-701に基づく）

---

### AC-065-008: 定型文からお気に入り登録 🔵

**Given**: PresetPhrase が存在する
**When**: `saveFromPreset(preset)` を実行する
**Then**:
- 新しいお気に入りが作成される
- お気に入りの content == 定型文の content
- お気に入りの id ≠ 定型文の id（新しいUUID）
- displayOrder は自動採番される

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（REQ-701に基づく）

---

### AC-065-009: アプリ再起動後のデータ保持 🔵

**Given**: お気に入りが保存されている
**When**: アプリを終了し、再起動する
**Then**:
- 再起動後も `loadAll()` で同じお気に入りが取得できる
- データ損失なし

**テスト方法**: Integration Test（または手動テスト）

**信頼性レベル**: 🔵 青信号（NFR-065-001に基づく）

---

### AC-065-010: お気に入り0件の状態 🟡

**Given**: お気に入りが1件も登録されていない
**When**: `loadAll()` を実行する
**Then**:
- 空のリスト `[]` が返る
- エラーが発生しない

**テスト方法**: Unit Test

**信頼性レベル**: 🟡 黄信号（EDGE-065-001に基づく）

---

### AC-065-011: 存在しないIDで削除 🔵

**Given**: お気に入りが保存されている
**When**: 存在しないIDで `delete("nonexistent")` を実行する
**Then**:
- 例外が発生しない
- 既存のお気に入りは影響を受けない

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（EDGE-065-002に基づく）

---

### AC-065-012: 存在しないIDで取得 🔵

**Given**: お気に入りが保存されている
**When**: 存在しないIDで `getById("nonexistent")` を実行する
**Then**:
- `null` が返る
- 例外が発生しない

**テスト方法**: Unit Test

**信頼性レベル**: 🔵 青信号（EDGE-065-003に基づく）

---

### AC-065-013: 重複登録の防止 🟡

**Given**: "こんにちは" という content のお気に入りが既に存在する
**When**: `isDuplicate("こんにちは")` を実行する
**Then**:
- `true` が返る

**Given**: "さようなら" という content のお気に入りが存在しない
**When**: `isDuplicate("さようなら")` を実行する
**Then**:
- `false` が返る

**テスト方法**: Unit Test

**信頼性レベル**: 🟡 黄信号（FR-065-004に基づく）

---

## テスト戦略

### テストケース構成

1. **基本CRUD操作テスト**（AC-065-001 〜 AC-065-003）
   - save, loadAll, getById, delete, deleteAll

2. **並び順管理テスト**（AC-065-004 〜 AC-065-006）
   - displayOrder ソート、単一更新、一括更新

3. **お気に入り登録元テスト**（AC-065-007 〜 AC-065-008）
   - 履歴から、定型文から

4. **境界値・エッジケーステスト**（AC-065-010 〜 AC-065-013）
   - 0件、存在しないID、重複

5. **永続化テスト**（AC-065-009）
   - アプリ再起動後のデータ保持

### テストカバレッジ目標

- FavoriteRepository: **90%以上**
- FavoriteItem モデル: **80%以上**
- 全体: **80%以上**

### テストツール

- `flutter test` - Unit Test
- `flutter_test` パッケージ
- Hive テスト用モック: `hive_test` または `mockito`

---

## 実装ファイル構成

### 新規作成ファイル

```
frontend/kotonoha_app/lib/
├── shared/models/
│   └── favorite_item.dart              # FavoriteItem Hiveモデル定義
└── features/favorite/data/
    └── favorite_repository.dart         # FavoriteRepository実装

frontend/kotonoha_app/test/
└── features/favorite/data/
    └── favorite_repository_test.dart    # FavoriteRepository単体テスト
```

### コード生成

```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

- `favorite_item.g.dart` が自動生成される（TypeAdapter）

---

## 依存関係

### 依存パッケージ

- `hive: ^2.2.3`
- `hive_flutter: ^1.1.0`
- `uuid: ^3.0.7`（UUID生成用）

### 依存タスク

- **TASK-0054**: Hive初期化（完了済み）
  - `Hive.initFlutter()` が実行済み
  - `FavoriteItem` のTypeAdapterを登録する必要あり

### 関連タスク（今後）

- **TASK-0066**: お気に入り一覧UI実装
- **TASK-0067**: お気に入り並び替えUI実装

---

## 参考資料

- **既存実装**: `frontend/kotonoha_app/lib/features/history/data/history_repository.dart`
- **既存モデル**: `frontend/kotonoha_app/lib/shared/models/history_item.dart`
- **要件定義書**: `docs/spec/kotonoha-requirements.md`（REQ-701〜704）
- **インターフェース定義**: `docs/design/kotonoha/interfaces.dart`（Favorite エンティティ）
- **アーキテクチャ設計**: `docs/design/kotonoha/architecture.md`（オフラインファースト設計）

---

## 備考

### 設計判断の理由

1. **HistoryItemと同じHive typeId体系を使用**
   - typeId 0: HistoryItem
   - typeId 1: 予約済み（将来用）
   - typeId 2: FavoriteItem

2. **Repository層でバリデーションを行わない理由**
   - 関心の分離（Repository は永続化のみ、ビジネスロジックはViewModel層）
   - テストしやすさ（境界値・エラーケースをUI層で制御）

3. **displayOrder の重複を許可する理由**
   - ユーザビリティ（エラーで操作を妨げない）
   - 並び替え時に自然に解消される

4. **履歴/定型文から登録時に新しいIDを生成する理由**
   - データ独立性（お気に入りは履歴/定型文とは別エンティティ）
   - 履歴削除後もお気に入りは保持される

---

## 信頼性レベルサマリー

- 🔵 **青信号**: 28項目（FR: 5, NFR: 5, EDGE: 4, AC: 10, その他: 4）
- 🟡 **黄信号**: 10項目（FR: 1, NFR: 1, EDGE: 7, AC: 1）
- 🔴 **赤信号**: 0項目

**全体信頼性**: 73.7%が確実な要件（🔵青信号）、26.3%が妥当な推測（🟡黄信号）

---

## 次のステップ

1. `/tsumiki:tdd-testcases` - テストケース洗い出し
2. `/tsumiki:tdd-red` - 失敗するテスト作成
3. `/tsumiki:tdd-green` - テストを通す実装
4. `/tsumiki:tdd-refactor` - リファクタリング
5. `/tsumiki:tdd-verify-complete` - 完了検証
