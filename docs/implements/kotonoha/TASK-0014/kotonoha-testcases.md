# TDDテストケース定義 - TASK-0014: Hiveローカルストレージセットアップ・データモデル実装

## タスク情報

- **タスクID**: TASK-0014
- **タスク名**: Hiveローカルストレージセットアップ・データモデル実装
- **タスクタイプ**: TDD
- **推定工数**: 8時間
- **作成日**: 2025-11-21

## 関連文書

- **要件定義書**: [docs/implements/kotonoha/TASK-0014/kotonoha-requirements.md](./kotonoha-requirements.md)
- **EARS要件定義書**: [docs/spec/kotonoha-requirements.md](../../spec/kotonoha-requirements.md)
- **アーキテクチャ設計**: [docs/design/kotonoha/architecture.md](../../design/kotonoha/architecture.md)
- **データフロー図**: [docs/design/kotonoha/dataflow.md](../../design/kotonoha/dataflow.md)
- **Dart型定義**: [docs/design/kotonoha/interfaces.dart](../../design/kotonoha/interfaces.dart)

---

## 開発言語・フレームワーク

### プログラミング言語
- **言語**: Dart 3.10+
- **言語選択の理由**:
  - Flutterの公式言語
  - Null Safetyで型安全性が高い
  - 非同期処理（async/await）が言語レベルでサポート
  - テストに適した機能: mock、stub、assertionが充実
- **テストに適した機能**:
  - `flutter_test`による豊富なマッチャー
  - 非同期テストの容易性
  - ホットリロードでテスト駆動開発が高速

### テストフレームワーク
- **フレームワーク**: flutter_test + Hive Testing
- **フレームワーク選択の理由**:
  - Flutterの公式テストフレームワーク
  - Hiveのモックが容易（`Hive.init()`, `setMockInitialValues()`相当）
  - ProviderContainerと統合しやすい
  - 既存のTASK-0013（SettingsProviderテスト）と同じパターンを踏襲
- **テスト実行環境**:
  - ローカル開発環境: `flutter test`
  - CI/CD: GitHub Actions
  - カバレッジ測定: `flutter test --coverage`

🔵 この内容の信頼性レベル: 青信号（tech-stack.md、既存テストファイルに基づく確実な選択）

---

## テストケース一覧（20件）

### 1. Hive初期化・TypeAdapter登録テスト（3件）

#### TC-001: Hive初期化成功テスト

- **テスト名**: Hive初期化が正常に完了し、ボックスがオープンできることを確認
  - **何をテストするか**: `initHive()`関数の正常動作確認
  - **期待される動作**: `Hive.initFlutter()`が成功し、ボックスがオープンされる
- **入力値**: なし（`initHive()`呼び出しのみ）
  - **入力データの意味**: アプリ初回起動時の初期化処理
- **期待される結果**:
  - `initHive()`が例外をスローせずに完了
  - `Hive.box<HistoryItem>('history')`と`Hive.box<PresetPhrase>('presetPhrases')`がオープン状態
  - **期待結果の理由**: REQ-5003（データ永続化）の基盤が確立される
- **テストの目的**: Hiveデータベースが正常に初期化され、アプリがローカルストレージを使用可能な状態になることを確認
  - **確認ポイント**:
    - Hive初期化が例外なく完了
    - ボックスが正常にオープンされる
    - main.dartからの呼び出しが正常動作

🔵 このテストケースの信頼性レベル: 青信号（REQ-5003、architecture.mdのHive使用要件に基づく）

---

#### TC-002: TypeAdapter登録成功テスト（HistoryItem, PresetPhrase）

- **テスト名**: `HistoryItemAdapter`と`PresetPhraseAdapter`が正しく登録されることを確認
  - **何をテストするか**: `Hive.registerAdapter()`の正常動作
  - **期待される動作**: 両TypeAdapterが登録され、データの保存・読み込みが可能になる
- **入力値**:
  - `Hive.registerAdapter(HistoryItemAdapter())`
  - `Hive.registerAdapter(PresetPhraseAdapter())`
  - **入力データの意味**: Hiveがカスタムクラスを保存するためのシリアライザー登録
- **期待される結果**:
  - TypeAdapter登録が成功
  - `HistoryItem`と`PresetPhrase`のインスタンスがHiveボックスに保存・読み込み可能
  - **期待結果の理由**: カスタムクラスのHive永続化に必須
- **テストの目的**: TypeAdapterが正しく登録され、カスタムクラスのシリアライズ/デシリアライズが機能することを確認
  - **確認ポイント**:
    - `Hive.isAdapterRegistered(0)`が`true`（HistoryItem）
    - `Hive.isAdapterRegistered(1)`が`true`（PresetPhrase）
    - 実際にインスタンスを保存・読み込みできる

🔵 このテストケースの信頼性レベル: 青信号（Hive公式ドキュメント、interfaces.dartの型定義に基づく）

---

#### TC-003: TypeAdapter重複登録時のエラーハンドリングテスト

- **テスト名**: 同じTypeAdapterを2回登録しようとした場合のエラーハンドリングを確認
  - **エラーケースの概要**: `Hive.registerAdapter()`を同じtypeIdで2回呼び出す
  - **エラー処理の重要性**: アプリ再起動時の冪等性保証、Hot Restartでのクラッシュ防止
- **入力値**:
  - 1回目: `Hive.registerAdapter(HistoryItemAdapter())` → 成功
  - 2回目: `Hive.registerAdapter(HistoryItemAdapter())` → エラー発生
  - **不正な理由**: Hiveは同じtypeIdのアダプターを複数登録できない
  - **実際の発生シナリオ**:
    - Hot Restart時に`initHive()`が再実行される
    - テスト実行時に複数回初期化される
- **期待される結果**:
  - `HiveError`が発生するか、既登録を検知して無視（try-catch処理）
  - アプリがクラッシュせず、正常に継続動作
  - **エラーメッセージの内容**: "Adapter already registered"相当
  - **システムの安全性**: NFR-301（基本機能継続）を満たす
- **テストの目的**: 重複登録エラーが適切にハンドリングされ、アプリの安定性が保たれることを確認
  - **品質保証の観点**:
    - 開発中のHot Restartでクラッシュしない
    - テスト実行の冪等性保証
    - 実装のロバスト性向上

🟡 このテストケースの信頼性レベル: 黄信号（NFR-301、NFR-304から類推、Hiveの一般的なエラーケース）

---

### 2. HistoryItem保存・読み込みテスト（5件）

#### TC-004: HistoryItem単一データの保存・読み込みテスト

- **テスト名**: `HistoryItem`を1件保存し、正しく読み込めることを確認
  - **何をテストするか**: Hiveボックスへの基本的なCRUD操作（Create, Read）
  - **期待される動作**: 保存したデータが同じ内容で読み込まれる
- **入力値**:
  ```dart
  final item = HistoryItem(
    id: 'test-uuid-001',
    content: 'ありがとう',
    createdAt: DateTime(2025, 11, 21, 10, 30),
    type: 'manualInput',
    isFavorite: false,
  );
  ```
  - **入力データの意味**: ユーザーが文字盤で「ありがとう」と入力し、読み上げた履歴
- **期待される結果**:
  - `historyBox.put(item.id, item)`が成功
  - `historyBox.get(item.id)`で同じ内容のインスタンスが取得できる
  - 全フィールドの値が一致（id, content, createdAt, type, isFavorite）
  - **期待結果の理由**: REQ-601（履歴自動保存）の基本動作
- **テストの目的**: Hiveの基本的な保存・読み込み機能が正常に動作することを確認
  - **確認ポイント**:
    - データの完全性（全フィールドが保持される）
    - 日時型（DateTime）の正確な保存・復元
    - String型（id, content, type）の正確性

🔵 このテストケースの信頼性レベル: 青信号（REQ-601、interfaces.dartのHistoryItem定義に基づく）

---

#### TC-005: HistoryItem複数データの保存・読み込みテスト

- **テスト名**: 複数の`HistoryItem`を保存し、全件を正しく読み込めることを確認
  - **何をテストするか**: 複数レコードの保存と、`values.toList()`による全件取得
  - **期待される動作**: 保存した順序とは無関係に、すべてのデータが取得できる
- **入力値**:
  ```dart
  final items = [
    HistoryItem(id: 'uuid-001', content: 'ありがとう', createdAt: DateTime(2025, 11, 21, 10, 0), type: 'manualInput', isFavorite: false),
    HistoryItem(id: 'uuid-002', content: 'お願いします', createdAt: DateTime(2025, 11, 21, 11, 0), type: 'preset', isFavorite: true),
    HistoryItem(id: 'uuid-003', content: '助けてください', createdAt: DateTime(2025, 11, 21, 12, 0), type: 'aiConverted', isFavorite: false),
  ];
  ```
  - **入力データの意味**: 1日の使用で蓄積された3件の履歴
- **期待される結果**:
  - すべての`item`が保存される
  - `historyBox.values.toList()`で3件取得できる
  - 各アイテムのフィールドが正確に保持される
  - **期待結果の理由**: REQ-602（履歴最大50件保持）の基盤動作
- **テストの目的**: 複数データの保存・一括取得が正常に機能することを確認
  - **確認ポイント**:
    - 件数の正確性（3件保存して3件取得）
    - データの独立性（各itemが混ざらない）
    - 異なるHistoryType（manualInput, preset, aiConverted）の保存

🔵 このテストケースの信頼性レベル: 青信号（REQ-602、dataflow.mdの履歴管理フローに基づく）

---

#### TC-006: HistoryItem削除テスト

- **テスト名**: 特定の`HistoryItem`を削除し、削除後に取得できないことを確認
  - **何をテストするか**: `historyBox.delete(key)`の正常動作
  - **期待される動作**: 削除したアイテムが取得できなくなる
- **入力値**:
  - 保存: `HistoryItem(id: 'uuid-001', content: 'テスト', ...)`
  - 削除: `historyBox.delete('uuid-001')`
  - **入力データの意味**: ユーザーが履歴画面から特定の履歴を削除する操作（REQ-604）
- **期待される結果**:
  - `historyBox.delete('uuid-001')`が成功
  - `historyBox.get('uuid-001')`が`null`を返す
  - `historyBox.length`が1減る
  - **期待結果の理由**: REQ-604（履歴個別削除機能）の実現
- **テストの目的**: 履歴削除機能が正常に動作し、削除したデータが確実に消えることを確認
  - **確認ポイント**:
    - データの物理削除（論理削除ではない）
    - 削除後の取得がnull
    - 他のデータに影響しない

🔵 このテストケースの信頼性レベル: 青信号（REQ-604の要件に基づく）

---

#### TC-007: 履歴50件超過時の自動削除テスト（REQ-602）

- **テスト名**: 履歴が50件に達した状態で新規追加時、最も古い履歴が自動削除されることを確認
  - **何をテストするか**: 履歴50件上限の自動削除ロジック
  - **期待される動作**: 51件目追加時に最古（最もcreatedAtが古い）が削除され、常に50件以下を維持
- **入力値**:
  - 50件のHistoryItemを保存（`id: 'uuid-001'` ~ `'uuid-050'`）
  - 51件目を追加: `HistoryItem(id: 'uuid-051', content: '新しい履歴', ...)`
  - **入力データの意味**: 長期利用ユーザーの履歴が上限に達したシナリオ
- **期待される結果**:
  - 51件目追加後、`historyBox.length`が50件
  - 最も古い履歴（`uuid-001`）が削除される
  - 最新の履歴（`uuid-051`）が存在する
  - **期待結果の理由**: REQ-602（履歴最大50件保持、古いものから自動削除）の要件
- **テストの目的**: 履歴上限管理が正常に動作し、ユーザーが最新50件を常に利用できることを確認
  - **確認ポイント**:
    - 50件上限が守られる（51件にならない）
    - 最古のデータが削除される（最新ではない）
    - データ整合性（他のデータが破損しない）

🔵 このテストケースの信頼性レベル: 青信号（REQ-602、REQ-3002の要件に基づく）

---

#### TC-008: 履歴0件時の表示テスト（EDGE-103）

- **テスト名**: 履歴が0件の状態で`historyBox.values`を取得した場合、空のリストが返されることを確認
  - **何をテストするか**: 履歴0件時のエッジケース処理
  - **期待される動作**: 空のIterable/Listが返され、エラーが発生しない
- **入力値**: なし（ボックスを空の状態で保持）
  - **入力データの意味**: アプリ初回起動時、または全削除後の状態
- **期待される結果**:
  - `historyBox.values.toList()`が空のリスト`[]`を返す
  - `historyBox.isEmpty`が`true`
  - 例外やエラーが発生しない
  - **期待結果の理由**: EDGE-103（履歴0件時のUI表示）の基盤
- **テストの目的**: 履歴0件時のエッジケースが正常に処理され、UIで「履歴がありません」メッセージを表示できることを確認
  - **確認ポイント**:
    - 空リストの正確な取得
    - null参照エラーの回避
    - UI表示の前提条件

🔵 このテストケースの信頼性レベル: 青信号（EDGE-103の要件に基づく）

---

### 3. PresetPhrase保存・読み込みテスト（5件）

#### TC-009: PresetPhrase単一データの保存・読み込みテスト

- **テスト名**: `PresetPhrase`を1件保存し、正しく読み込めることを確認
  - **何をテストするか**: PresetPhraseのCRUD操作（Create, Read）
  - **期待される動作**: 保存したデータが同じ内容で読み込まれる
- **入力値**:
  ```dart
  final preset = PresetPhrase(
    id: 'preset-uuid-001',
    content: 'お水をください',
    category: 'health',
    isFavorite: true,
    displayOrder: 0,
    createdAt: DateTime(2025, 11, 21, 10, 0),
    updatedAt: DateTime(2025, 11, 21, 10, 0),
  );
  ```
  - **入力データの意味**: ユーザーが設定画面で新規登録した定型文
- **期待される結果**:
  - `presetBox.put(preset.id, preset)`が成功
  - `presetBox.get(preset.id)`で同じ内容のインスタンスが取得できる
  - 全フィールドの値が一致
  - **期待結果の理由**: REQ-104（定型文追加機能）の基本動作
- **テストの目的**: PresetPhraseの基本的な保存・読み込み機能が正常に動作することを確認
  - **確認ポイント**:
    - データの完全性（全7フィールドが保持される）
    - category（String型）の正確性
    - displayOrder（int型）の正確性

🔵 このテストケースの信頼性レベル: 青信号（REQ-104、interfaces.dartのPresetPhrase定義に基づく）

---

#### TC-010: PresetPhrase複数データの保存・読み込みテスト

- **テスト名**: 複数の`PresetPhrase`を保存し、全件を正しく読み込めることを確認
  - **何をテストするか**: 複数定型文の保存と全件取得
  - **期待される動作**: すべての定型文が正確に保存・取得できる
- **入力値**:
  ```dart
  final presets = [
    PresetPhrase(id: 'preset-001', content: 'おはようございます', category: 'daily', isFavorite: true, displayOrder: 0, ...),
    PresetPhrase(id: 'preset-002', content: 'お水をください', category: 'health', isFavorite: true, displayOrder: 1, ...),
    PresetPhrase(id: 'preset-003', content: 'ありがとう', category: 'daily', isFavorite: false, displayOrder: 2, ...),
  ];
  ```
  - **入力データの意味**: ユーザーがよく使う定型文3件（日常2件、体調1件）
- **期待される結果**:
  - すべてのpresetが保存される
  - `presetBox.values.toList()`で3件取得できる
  - 異なるカテゴリ（daily, health）が混在して保存できる
  - **期待結果の理由**: REQ-106（カテゴリ分類）の基盤動作
- **テストの目的**: 複数定型文の保存・一括取得が正常に機能することを確認
  - **確認ポイント**:
    - 件数の正確性
    - カテゴリ別の保存（daily, health, other）
    - isFavoriteフラグの保持

🔵 このテストケースの信頼性レベル: 青信号（REQ-104、REQ-106、dataflow.mdの定型文管理フローに基づく）

---

#### TC-011: PresetPhraseカテゴリ分類テスト（daily, health, other）

- **テスト名**: 3種類のカテゴリ（daily, health, other）の定型文がそれぞれ正しく保存・識別できることを確認
  - **何をテストするか**: categoryフィールドの正確な保存と読み込み
  - **期待される動作**: カテゴリごとにデータが正しく分類される
- **入力値**:
  ```dart
  final dailyPreset = PresetPhrase(id: 'preset-daily', content: 'おはよう', category: 'daily', ...);
  final healthPreset = PresetPhrase(id: 'preset-health', content: '痛いです', category: 'health', ...);
  final otherPreset = PresetPhrase(id: 'preset-other', content: '趣味の話', category: 'other', ...);
  ```
  - **入力データの意味**: REQ-106で定義された3種類のカテゴリすべて
- **期待される結果**:
  - 各presetが正しいcategoryで保存される
  - 読み込み時にcategoryフィールドが正確に復元される
  - カテゴリごとにフィルタリング可能（`where`句で分類可能）
  - **期待結果の理由**: REQ-106（カテゴリ分類）の実現
- **テストの目的**: カテゴリ分類機能が正常に動作し、UIで「日常」「体調」「その他」タブ表示が可能になることを確認
  - **確認ポイント**:
    - 3種類すべてのカテゴリが保存可能
    - String型のcategoryフィールドの正確性
    - カテゴリごとのフィルタリング可能性

🔵 このテストケースの信頼性レベル: 青信号（REQ-106の要件に基づく）

---

#### TC-012: PresetPhraseお気に入りフラグテスト

- **テスト名**: `isFavorite`フラグがtrueの定型文とfalseの定型文が正しく識別できることを確認
  - **何をテストするか**: isFavoriteフラグの保存と読み込み
  - **期待される動作**: お気に入りフラグがbool型で正確に保持される
- **入力値**:
  ```dart
  final favoritePreset = PresetPhrase(id: 'fav-001', content: 'よく使う', isFavorite: true, ...);
  final normalPreset = PresetPhrase(id: 'normal-001', content: 'たまに使う', isFavorite: false, ...);
  ```
  - **入力データの意味**: お気に入り登録済み定型文と通常定型文
- **期待される結果**:
  - `isFavorite: true`のpresetが正しく保存・復元される
  - `isFavorite: false`のpresetが正しく保存・復元される
  - お気に入りのみフィルタリング可能（`where((p) => p.isFavorite)`）
  - **期待結果の理由**: REQ-105（お気に入り優先表示）の基盤
- **テストの目的**: お気に入り機能が正常に動作し、UIで上部に優先表示できることを確認
  - **確認ポイント**:
    - bool型の正確な保存
    - true/falseの識別
    - お気に入りフィルタリングの可能性

🔵 このテストケースの信頼性レベル: 青信号（REQ-105の要件に基づく）

---

#### TC-013: PresetPhrase削除テスト

- **テスト名**: 特定の`PresetPhrase`を削除し、削除後に取得できないことを確認
  - **何をテストするか**: `presetBox.delete(key)`の正常動作
  - **期待される動作**: 削除した定型文が取得できなくなる
- **入力値**:
  - 保存: `PresetPhrase(id: 'preset-001', content: '削除予定', ...)`
  - 削除: `presetBox.delete('preset-001')`
  - **入力データの意味**: ユーザーが設定画面から不要な定型文を削除する操作（REQ-104）
- **期待される結果**:
  - `presetBox.delete('preset-001')`が成功
  - `presetBox.get('preset-001')`が`null`を返す
  - `presetBox.length`が1減る
  - **期待結果の理由**: REQ-104（定型文削除機能）の実現
- **テストの目的**: 定型文削除機能が正常に動作し、削除したデータが確実に消えることを確認
  - **確認ポイント**:
    - データの物理削除
    - 削除後の取得がnull
    - 他のデータに影響しない

🔵 このテストケースの信頼性レベル: 青信号（REQ-104の要件に基づく）

---

### 4. データ永続化・復元テスト（2件）

#### TC-014: アプリ再起動後のHistoryItem復元テスト（REQ-5003）

- **テスト名**: アプリ再起動後、保存されたHistoryItemが正しく復元されることを確認
  - **何をテストするか**: Hiveの永続化機能（ディスク書き込み）
  - **期待される動作**: アプリ再起動後も全データが保持される
- **入力値**:
  - 1回目のセッション:
    ```dart
    final item = HistoryItem(id: 'uuid-001', content: 'テスト', ...);
    await historyBox.put(item.id, item);
    await historyBox.close(); // アプリ終了を模擬
    ```
  - 2回目のセッション:
    ```dart
    await Hive.openBox<HistoryItem>('history'); // 再起動を模擬
    final restored = historyBox.get('uuid-001');
    ```
  - **入力データの意味**: アプリを終了し、翌日再起動したシナリオ
- **期待される結果**:
  - 再起動後、`historyBox.get('uuid-001')`で保存したデータが取得できる
  - 全フィールドの値が元のデータと一致
  - **期待結果の理由**: REQ-5003（アプリクラッシュ後もデータ保持）の要件
- **テストの目的**: データ永続化が正常に機能し、ユーザーが過去の履歴を失わないことを確認
  - **確認ポイント**:
    - ディスクへの書き込み完了
    - 再起動後の読み込み成功
    - データの完全性

🔵 このテストケースの信頼性レベル: 青信号（REQ-5003の要件に基づく）

---

#### TC-015: アプリ再起動後のPresetPhrase復元テスト（REQ-5003）

- **テスト名**: アプリ再起動後、保存されたPresetPhraseが正しく復元されることを確認
  - **何をテストするか**: 定型文の永続化機能
  - **期待される動作**: アプリ再起動後も全定型文が保持される
- **入力値**:
  - 1回目のセッション:
    ```dart
    final preset = PresetPhrase(id: 'preset-001', content: 'お水をください', category: 'health', ...);
    await presetBox.put(preset.id, preset);
    await presetBox.close(); // アプリ終了を模擬
    ```
  - 2回目のセッション:
    ```dart
    await Hive.openBox<PresetPhrase>('presetPhrases'); // 再起動を模擬
    final restored = presetBox.get('preset-001');
    ```
  - **入力データの意味**: 設定した定型文がアプリ終了後も保持される
- **期待される結果**:
  - 再起動後、全定型文が復元される
  - カテゴリ、お気に入りフラグ、displayOrderが正確に復元される
  - **期待結果の理由**: REQ-5003（設定永続化）の要件
- **テストの目的**: 定型文の永続化が正常に機能し、ユーザーが登録した定型文を失わないことを確認
  - **確認ポイント**:
    - ディスクへの書き込み完了
    - 再起動後の読み込み成功
    - 全フィールドの正確性

🔵 このテストケースの信頼性レベル: 青信号（REQ-5003の要件に基づく）

---

### 5. エラーハンドリングテスト（3件）

#### TC-016: ボックスオープン失敗時のエラーハンドリングテスト

- **テスト名**: `Hive.openBox()`が失敗した場合のエラーハンドリングを確認
  - **エラーケースの概要**: ボックスが破損している、ディスク容量不足、権限エラー等
  - **エラー処理の重要性**: NFR-301（基本機能継続）、NFR-304（エラーハンドリング）
- **入力値**:
  - 破損したボックスファイルをシミュレート（またはモック）
  - `await Hive.openBox<HistoryItem>('history')` → 例外発生
  - **不正な理由**: ファイルシステム障害、データ破損、OSアップデート等
  - **実際の発生シナリオ**:
    - ストレージ容量不足でボックスが破損
    - OSアップデート後の互換性問題
    - アプリ強制終了時のデータ破損
- **期待される結果**:
  - エラーが適切にキャッチされる（try-catch）
  - ログにエラーが記録される
  - 破損したボックスを削除し、新しいボックスを作成（`Hive.deleteBoxFromDisk()`）
  - ユーザーに通知（「履歴データを初期化しました」）
  - アプリがクラッシュせず、基本機能が継続動作
  - **エラーメッセージの内容**: 「データベースエラーが発生しました。履歴を初期化します」
  - **システムの安全性**: NFR-301（基本機能継続）を満たす
- **テストの目的**: ボックスオープン失敗時もアプリが安全に復旧し、ユーザーが基本機能を使い続けられることを確認
  - **品質保証の観点**:
    - 自動復旧機能の動作確認
    - ユーザー体験の維持
    - データ損失の最小化

🟡 このテストケースの信頼性レベル: 黄信号（NFR-301、NFR-304、要件定義書「エラー3」から類推）

---

#### TC-017: ストレージ容量不足時のエラーハンドリングテスト（EDGE-003）

- **テスト名**: ストレージ容量不足で`put()`が失敗した場合のエラーハンドリングを確認
  - **エラーケースの概要**: ディスク容量不足でHiveへの書き込みが失敗
  - **エラー処理の重要性**: EDGE-003の要件、データ損失防止
- **入力値**:
  - ストレージ容量不足をシミュレート（モック）
  - `await historyBox.put(item.id, item)` → 例外発生
  - **不正な理由**: 端末のストレージが満杯
  - **実際の発生シナリオ**:
    - 写真・動画で端末容量が逼迫
    - 長期使用で履歴が大量蓄積
- **期待される結果**:
  - `HiveError`または`IOException`がキャッチされる
  - ユーザーに警告表示（「容量が不足しています。古い履歴を削除しますか?」）
  - 古い履歴を一括削除する選択肢を提供
  - アプリがクラッシュしない
  - **エラーメッセージの内容**: 「ストレージ容量が不足しています」
  - **システムの安全性**: EDGE-003の要件を満たす
- **テストの目的**: ストレージ容量不足時もアプリが安全に動作し、ユーザーに適切な対処法を提示することを確認
  - **品質保証の観点**:
    - エラーの適切な検出
    - ユーザーフレンドリーなエラーメッセージ
    - データ整理機能の提供

🟡 このテストケースの信頼性レベル: 黄信号（EDGE-003の要件、要件定義書「エッジケース3」から類推）

---

#### TC-018: 文字数上限超過時のバリデーションテスト（EDGE-101, EDGE-102）

- **テスト名**: 1000文字を超える履歴、500文字を超える定型文を保存しようとした場合のバリデーションを確認
  - **エラーケースの概要**: 文字数上限超過データの保存試行
  - **エラー処理の重要性**: EDGE-101、EDGE-102の要件、データ整合性維持
- **入力値**:
  - 履歴: `content`が1001文字のHistoryItem
  - 定型文: `content`が501文字のPresetPhrase
  - **不正な理由**: EDGE-101（履歴1000文字制限）、EDGE-102（定型文500文字制限）
  - **実際の発生シナリオ**:
    - ユーザーが長文を入力
    - コピー&ペーストで大量テキスト入力
- **期待される結果**:
  - 保存前にバリデーションでエラー検出
  - 1000文字/500文字でカット、または警告表示
  - エラーメッセージ（「定型文は500文字以内にしてください」）
  - Hiveへの保存前にアプリ層で制限
  - **エラーメッセージの内容**: 「入力は○○文字以内にしてください」
  - **システムの安全性**: データ整合性維持、パフォーマンス保証
- **テストの目的**: 文字数上限が適切に制限され、データ品質が維持されることを確認
  - **品質保証の観点**:
    - バリデーションの正確性
    - ユーザーへの明確なフィードバック
    - データベースの整合性維持

🟡 このテストケースの信頼性レベル: 黄信号（EDGE-101、EDGE-102の要件から類推）

---

### 6. パフォーマンステスト（2件）

#### TC-019: 100件の定型文読み込み速度テスト（NFR-004: 1秒以内）

- **テスト名**: 100件の`PresetPhrase`をHiveから読み込み、1秒以内に完了することを確認
  - **何をテストするか**: Hiveの読み込みパフォーマンス
  - **期待される動作**: NFR-004の要件（1秒以内）を満たす
- **入力値**:
  - 100件のPresetPhraseを事前に保存
  - `final stopwatch = Stopwatch()..start();`
  - `final presets = presetBox.values.toList();`
  - `stopwatch.stop();`
  - **入力データの意味**: REQ-107（50-100個の初期データ）を想定
- **期待される結果**:
  - 読み込み時間が1秒以内（`stopwatch.elapsedMilliseconds < 1000`）
  - 理想的には100ms以内（Hiveの性能を考慮）
  - 全100件が正確に取得できる
  - **期待結果の理由**: NFR-004（定型文一覧表示1秒以内）の要件
- **テストの目的**: 定型文一覧表示が高速に動作し、ユーザーストレスなく利用できることを確認
  - **確認ポイント**:
    - 実測時間の記録
    - パフォーマンス要件の達成
    - スケーラビリティの確認

🟡 このテストケースの信頼性レベル: 黄信号（NFR-004の要件に基づくが、実測が必要）

---

#### TC-020: 履歴保存速度テスト（50ms以内目標）

- **テスト名**: 1件の`HistoryItem`をHiveに保存し、50ms以内に完了することを確認
  - **何をテストするか**: Hiveの書き込みパフォーマンス
  - **期待される動作**: UI応答性を阻害しない高速保存
- **入力値**:
  - `final stopwatch = Stopwatch()..start();`
  - `await historyBox.put(item.id, item);`
  - `stopwatch.stop();`
  - **入力データの意味**: TTS読み上げ直後の履歴自動保存（REQ-601）
- **期待される結果**:
  - 保存時間が50ms以内（`stopwatch.elapsedMilliseconds < 50`）
  - UIがブロックされない（非同期処理）
  - データが確実に保存される
  - **期待結果の理由**: REQ-601（自動保存がユーザー体験を阻害しない）
- **テストの目的**: 履歴自動保存が高速に完了し、ユーザーが待たされないことを確認
  - **確認ポイント**:
    - 実測時間の記録
    - 非同期処理の動作確認
    - UI応答性の維持

🟡 このテストケースの信頼性レベル: 黄信号（要件定義書から類推した目標値、実測が必要）

---

## テストケース実装時の日本語コメント指針

すべてのテストケース実装時には、以下の日本語コメントを含めてください：

### テストケース開始時のコメント

```dart
// 【テスト目的】: このテストで何を確認するかを日本語で明記
// 【テスト内容】: 具体的にどのような処理をテストするかを説明
// 【期待される動作】: 正常に動作した場合の結果を説明
// 🔵🟡🔴 この内容の信頼性レベルを記載
```

### Given（準備フェーズ）のコメント

```dart
// 【テストデータ準備】: なぜこのデータを用意するかの理由
// 【初期条件設定】: テスト実行前の状態を説明
// 【前提条件確認】: テスト実行に必要な前提条件を明記
```

### When（実行フェーズ）のコメント

```dart
// 【実際の処理実行】: どの機能/メソッドを呼び出すかを説明
// 【処理内容】: 実行される処理の内容を日本語で説明
// 【実行タイミング】: なぜこのタイミングで実行するかを説明
```

### Then（検証フェーズ）のコメント

```dart
// 【結果検証】: 何を検証するかを具体的に説明
// 【期待値確認】: 期待される結果とその理由を説明
// 【品質保証】: この検証がシステム品質にどう貢献するかを説明
```

### 各expectステートメントのコメント

```dart
// 【検証項目】: この検証で確認している具体的な項目
// 🔵🟡🔴 この内容の信頼性レベルを記載
expect(historyBox.length, 50); // 【確認内容】: 履歴が常に50件以下に保たれることを確認
expect(historyBox.get('uuid-051'), isNotNull); // 【確認内容】: 最新の履歴が存在することを確認
```

### セットアップ・クリーンアップのコメント

```dart
setUp(() async {
  // 【テスト前準備】: 各テスト実行前に行う準備作業の説明
  // 【環境初期化】: テスト環境をクリーンな状態にする理由と方法
  await Hive.initFlutter();
  await Hive.openBox<HistoryItem>('history');
});

tearDown(() async {
  // 【テスト後処理】: 各テスト実行後に行うクリーンアップ作業の説明
  // 【状態復元】: 次のテストに影響しないよう状態を復元する理由
  await Hive.deleteBoxFromDisk('history');
  await Hive.close();
});
```

---

## 次のステップ

このテストケース定義書を基に、以下の流れでTDD開発を進めます：

### 推奨コマンド
次は `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

### Redフェーズで実装する内容
1. **TC-001～TC-003**: Hive初期化・TypeAdapter登録の失敗テスト
2. **TC-004～TC-008**: HistoryItemの失敗テスト
3. **TC-009～TC-013**: PresetPhraseの失敗テスト
4. **TC-014～TC-015**: データ永続化の失敗テスト
5. **TC-016～TC-018**: エラーハンドリングの失敗テスト
6. **TC-019～TC-020**: パフォーマンステストの失敗テスト

### 実装順序
1. Hive初期化・TypeAdapter登録（TC-001～TC-003）
2. HistoryItem基本操作（TC-004～TC-006）
3. PresetPhrase基本操作（TC-009～TC-011）
4. データ永続化（TC-014～TC-015）
5. エッジケース（TC-007, TC-008, TC-012, TC-013）
6. エラーハンドリング（TC-016～TC-018）
7. パフォーマンス（TC-019～TC-020）

---

## 品質判定

### ✅ 高品質（以下の基準を満たす）

#### テストケース分類
- ✅ 正常系・異常系・境界値が網羅されている
  - 正常系: TC-001, TC-002, TC-004, TC-005, TC-009, TC-010, TC-014, TC-015
  - 異常系: TC-003, TC-016, TC-017, TC-018
  - 境界値: TC-007, TC-008

#### 期待値定義
- ✅ 各テストケースの期待値が明確
  - 入力値、期待される結果、理由がすべて記載
  - Given-When-Thenパターンの明確化

#### 技術選択
- ✅ プログラミング言語・テストフレームワークが確定
  - Dart 3.10+ + flutter_test
  - Hive 2.2.3+
  - 既存テストパターン（TASK-0013）と統一

#### 実装可能性
- ✅ 現在の技術スタックで実現可能
  - pubspec.yamlに必要なパッケージが揃っている（hive, hive_flutter）
  - 既存プロジェクト構造に適合

### 信頼性レベルの内訳
- 🔵 青信号（15件/20件）: 75%
  - TC-001, TC-002, TC-004, TC-005, TC-006, TC-007, TC-008, TC-009, TC-010, TC-011, TC-012, TC-013, TC-014, TC-015
- 🟡 黄信号（5件/20件）: 25%
  - TC-003, TC-016, TC-017, TC-018, TC-019, TC-020

**結論**: 高品質なテストケース定義が完成しました。次のRedフェーズに進めます。

---

## 更新履歴

- **2025-11-21**: TDDテストケース定義書作成（/tsumiki:tdd-testcasesにより生成）
  - 20件のテストケースを詳細に洗い出し
  - EARS要件定義書（REQ-601, REQ-602, REQ-104, REQ-5003等）を参照
  - 既存テストパターン（TASK-0013）を踏襲
  - Given-When-Thenパターンの採用
  - 信頼性レベル（🔵🟡🔴）を各テストケースに明記
