# TDDテストケース仕様書: 初回マイグレーション実行・DB接続テスト

**タスクID**: TASK-0009
**機能名**: 初回マイグレーション実行・DB接続テスト
**作成日**: 2025-11-20
**更新日**: 2025-11-20

---

## 開発言語・テストフレームワーク

### プログラミング言語

- **Python 3.11以上**
  - **言語選択の理由**: バックエンドがPythonベース（FastAPI）であり、既存のテストコード（TASK-0008）がPython + pytestで実装されている
  - **テストに適した機能**: asyncio対応、型ヒント、pytest-asyncioによる非同期テストサポート
- 🔵 この内容は既存実装（backend/tests/conftest.py, test_models.py等）に基づく

### テストフレームワーク

- **pytest 7.4.x + pytest-asyncio 0.25.x**
  - **フレームワーク選択の理由**: 既存テスト（TASK-0008）がpytestで実装されており、非同期テストの実績がある
  - **テスト実行環境**: Dockerコンテナ内PostgreSQLデータベースに接続してテストを実行
  - **テストデータベース**: `kotonoha_test` データベースを使用（本番DBと分離）
- 🔵 この内容は既存実装（backend/tests/conftest.py line 21-24）に基づく

### テスト補助ツール

- **Alembic 1.17.1**: マイグレーション実行・ロールバックのテスト用
- **SQLAlchemy 2.0.36**: データベース接続・CRUD操作のテスト用
- **Docker + docker-compose**: PostgreSQL 15コンテナを使用した統合テスト環境
- 🔵 この内容は既存実装（backend/alembic.ini, docker-compose.yml）に基づく

---

## テストケース分類

このテストケース仕様書では、以下のカテゴリに分けてテストを実施します：

### カテゴリA: Alembicマイグレーション生成テスト
- マイグレーションファイルの自動生成機能を検証

### カテゴリB: マイグレーション実行テスト
- `alembic upgrade head` による初回マイグレーション実行を検証

### カテゴリC: テーブル作成確認テスト
- PostgreSQLにテーブルが正しく作成されたことを検証

### カテゴリD: マイグレーションロールバックテスト
- `alembic downgrade -1` による巻き戻し機能を検証

### カテゴリE: データベース接続テスト
- データベース接続の基本機能を検証

### カテゴリF: CRUD操作テスト（統合テスト）
- マイグレーション後のテーブルに対するCRUD操作を検証

### カテゴリG: エラーハンドリングテスト
- データベース接続エラー、制約違反などの異常系を検証

### カテゴリH: マイグレーション冪等性テスト
- 複数回実行時の動作を検証

---

## 正常系テストケース（基本的な動作）

### カテゴリA: Alembicマイグレーション生成テスト

#### A-1. マイグレーションファイルが自動生成される

- **テスト名**: test_alembic_revision_generation
  - **何をテストするか**: `alembic revision --autogenerate` コマンドでマイグレーションファイルが生成されること
  - **期待される動作**: `backend/alembic/versions/` ディレクトリに新しいマイグレーションファイルが作成される
- **入力値**:
  - マイグレーションメッセージ: `"Create ai_conversion_history table"`
  - モデル定義: `AIConversionHistory` クラス（既にTASK-0008で実装済み）
  - **入力データの意味**: 既存のSQLAlchemyモデルから差分を検出してマイグレーションファイルを生成
- **期待される結果**:
  - マイグレーションファイル: `{revision_id}_create_ai_conversion_history_table.py` が生成される
  - ファイルに `upgrade()` 関数が含まれる（CREATE TABLE文）
  - ファイルに `downgrade()` 関数が含まれる（DROP TABLE文）
  - **期待結果の理由**: Alembicの自動生成機能により、モデル定義から正しいSQLが生成される
- **テストの目的**: マイグレーションファイル生成機能が正常に動作することを確認
  - **確認ポイント**: ファイルが存在し、upgrade/downgrade関数が正しく記述されているか
- 🔵 この内容は要件定義書（line 46-57, line 169-183）に基づく

#### A-2. 生成されたマイグレーションファイルにai_conversion_historyテーブルのCREATE文が含まれる

- **テスト名**: test_migration_file_contains_create_table_statement
  - **何をテストするか**: 生成されたマイグレーションファイルの `upgrade()` 関数に正しいCREATE TABLE文が含まれること
  - **期待される動作**: `op.create_table('ai_conversion_history', ...)` が含まれる
- **入力値**:
  - 生成されたマイグレーションファイル（A-1で生成されたもの）
  - **入力データの意味**: Alembicが生成したPythonコードの内容を検証
- **期待される結果**:
  - `op.create_table('ai_conversion_history')` が存在する
  - カラム定義が含まれる: `id`, `input_text`, `converted_text`, `politeness_level`, `created_at`, `conversion_time_ms`, `user_session_id`
  - **期待結果の理由**: モデル定義（AIConversionHistory）がマイグレーションファイルに正確に反映される
- **テストの目的**: マイグレーションファイルの内容が正しく生成されることを確認
  - **確認ポイント**: テーブル名とカラム定義がモデルと一致しているか
- 🔵 この内容は要件定義書（line 46-57）とdatabase-schema.sql（line 36-68）に基づく

#### A-3. 生成されたマイグレーションファイルにインデックス作成文が含まれる

- **テスト名**: test_migration_file_contains_index_creation
  - **何をテストするか**: 生成されたマイグレーションファイルにインデックス作成文が含まれること
  - **期待される動作**: `op.create_index()` でインデックスが作成される
- **入力値**:
  - 生成されたマイグレーションファイル（A-1で生成されたもの）
  - **入力データの意味**: インデックス定義の確認
- **期待される結果**:
  - `idx_ai_conversion_created_at` インデックスが含まれる（created_at DESC）
  - `idx_ai_conversion_session` インデックスが含まれる（user_session_id）
  - **期待結果の理由**: データベーススキーマ（database-schema.sql）で定義されたインデックスが正しく反映される
- **テストの目的**: パフォーマンス最適化のためのインデックスが正しく定義されているか確認
  - **確認ポイント**: インデックス名、対象カラム、ソート順が正しいか
- 🔵 この内容は要件定義書（line 126-128）とdatabase-schema.sql（line 54-68）に基づく

### カテゴリB: マイグレーション実行テスト

#### B-1. 初回マイグレーション実行が成功する

- **テスト名**: test_alembic_upgrade_head_success
  - **何をテストするか**: `alembic upgrade head` コマンドが正常に完了すること
  - **期待される動作**: マイグレーションがエラーなく実行され、終了コード0が返される
- **入力値**:
  - コマンド: `alembic upgrade head`
  - 環境変数: POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_HOST, POSTGRES_PORT, POSTGRES_DB
  - **入力データの意味**: データベース接続情報を環境変数から読み込み、マイグレーション実行
- **期待される結果**:
  - 終了コード: 0（成功）
  - 標準出力に "Running upgrade" メッセージが含まれる
  - エラーが発生しない
  - **期待結果の理由**: Alembicマイグレーションが正常に実行される
- **テストの目的**: マイグレーション実行コマンドが正常に動作することを確認
  - **確認ポイント**: エラーなく実行され、成功メッセージが出力されるか
- 🔵 この内容は要件定義書（line 60-69, line 169-183）に基づく

#### B-2. マイグレーション実行後にalembic_versionテーブルにリビジョンが記録される

- **テスト名**: test_alembic_version_table_updated
  - **何をテストするか**: マイグレーション実行後、`alembic_version` テーブルに現在のリビジョンが記録されること
  - **期待される動作**: `alembic_version` テーブルに最新のリビジョンIDが1行だけ記録される
- **入力値**:
  - マイグレーション実行後のデータベース状態
  - **入力データの意味**: Alembicがリビジョン管理に使用する内部テーブルの確認
- **期待される結果**:
  - `SELECT * FROM alembic_version` の結果が1行である
  - `version_num` カラムに最新のリビジョンIDが記録されている
  - **期待結果の理由**: Alembicがマイグレーション履歴を正しく管理している
- **テストの目的**: マイグレーション履歴管理機能が正常に動作することを確認
  - **確認ポイント**: リビジョンIDが正しく記録され、重複がないか
- 🔵 この内容は要件定義書（line 68, line 299-304）に基づく

### カテゴリC: テーブル作成確認テスト

#### C-1. ai_conversion_historyテーブルが作成される

- **テスト名**: test_ai_conversion_history_table_exists
  - **何をテストするか**: マイグレーション実行後、`ai_conversion_history` テーブルがデータベースに存在すること
  - **期待される動作**: `information_schema.tables` から該当テーブルが検出される
- **入力値**:
  - テーブル名: `"ai_conversion_history"`
  - スキーマ名: `"public"`
  - **入力データの意味**: PostgreSQLのメタデータカタログを使用してテーブル存在確認
- **期待される結果**:
  - `information_schema.tables` から `ai_conversion_history` が検出される（TRUE）
  - テーブルタイプが `BASE TABLE` である
  - **期待結果の理由**: マイグレーションによりテーブルが正常に作成される
- **テストの目的**: テーブル作成が成功したことを確認
  - **確認ポイント**: テーブルが実際にデータベースに存在するか
- 🔵 この内容は要件定義書（line 82-89, line 397-398）に基づく

#### C-2. ai_conversion_historyテーブルに必須カラムがすべて存在する

- **テスト名**: test_ai_conversion_history_table_has_all_columns
  - **何をテストするか**: テーブルに必要なすべてのカラムが作成されていること
  - **期待される動作**: `information_schema.columns` から7つのカラムが検出される
- **入力値**:
  - テーブル名: `"ai_conversion_history"`
  - 期待されるカラム: `id`, `input_text`, `converted_text`, `politeness_level`, `created_at`, `conversion_time_ms`, `user_session_id`
  - **入力データの意味**: データベーススキーマ定義（database-schema.sql）と一致するか確認
- **期待される結果**:
  - カラム数: 7個
  - 各カラム名が正確に一致する
  - **期待結果の理由**: モデル定義がデータベーススキーマに正しく反映される
- **テストの目的**: テーブル構造が設計通りに作成されることを確認
  - **確認ポイント**: カラム名、カラム数が設計書と一致しているか
- 🔵 この内容は要件定義書（line 52-66）とdatabase-schema.sql（line 36-51）に基づく

#### C-3. ai_conversion_historyテーブルのカラムに正しいデータ型が設定されている

- **テスト名**: test_ai_conversion_history_table_column_types
  - **何をテストするか**: 各カラムのデータ型がdatabase-schema.sqlの定義と一致すること
  - **期待される動作**: `information_schema.columns` から各カラムのデータ型を取得し、検証
- **入力値**:
  - カラム定義:
    - `id`: INTEGER
    - `input_text`: TEXT
    - `converted_text`: TEXT
    - `politeness_level`: VARCHAR (Enum型)
    - `created_at`: TIMESTAMP WITH TIME ZONE
    - `conversion_time_ms`: INTEGER
    - `user_session_id`: UUID
  - **入力データの意味**: PostgreSQLのデータ型定義を確認
- **期待される結果**:
  - 各カラムのデータ型が期待値と一致する
  - **期待結果の理由**: SQLAlchemyモデルの型定義がデータベースに正しく反映される
- **テストの目的**: データ型定義が正確に実装されることを確認
  - **確認ポイント**: 型名、サイズ、精度が設計書と一致しているか
- 🔵 この内容はdatabase-schema.sql（line 37-51）とAIConversionHistoryモデル定義に基づく

#### C-4. ai_conversion_historyテーブルにNOT NULL制約が正しく設定されている

- **テスト名**: test_ai_conversion_history_not_null_constraints
  - **何をテストするか**: 必須カラムにNOT NULL制約が設定されていること
  - **期待される動作**: `information_schema.columns` の `is_nullable` カラムから制約を確認
- **入力値**:
  - NOT NULLカラム: `id`, `input_text`, `converted_text`, `politeness_level`, `created_at`
  - NULL許可カラム: `conversion_time_ms`, `user_session_id`
  - **入力データの意味**: データベース制約の検証
- **期待される結果**:
  - NOT NULLカラムの `is_nullable` が `NO`
  - NULL許可カラムの `is_nullable` が `YES`
  - **期待結果の理由**: モデル定義の `nullable=False/True` が正しく反映される
- **テストの目的**: データ整合性制約が正しく実装されることを確認
  - **確認ポイント**: 制約が設計書通りに設定されているか
- 🔵 この内容は要件定義書（line 122, line 146）とdatabase-schema.sql（line 37-51）に基づく

#### C-5. ai_conversion_historyテーブルに主キー制約が設定されている

- **テスト名**: test_ai_conversion_history_primary_key
  - **何をテストするか**: `id` カラムに主キー制約が設定されていること
  - **期待される動作**: `information_schema.table_constraints` から主キー制約が検出される
- **入力値**:
  - テーブル名: `"ai_conversion_history"`
  - 期待される主キーカラム: `id`
  - **入力データの意味**: 主キー制約の検証
- **期待される結果**:
  - `id` カラムが PRIMARY KEY として定義されている
  - 主キー制約名が存在する（例: `ai_conversion_history_pkey`）
  - **期待結果の理由**: モデル定義の `primary_key=True` が正しく反映される
- **テストの目的**: 主キー制約が正しく設定されることを確認
  - **確認ポイント**: 主キーが存在し、正しいカラムに設定されているか
- 🔵 この内容は要件定義書（line 124）とdatabase-schema.sql（line 37）に基づく

#### C-6. ai_conversion_historyテーブルにインデックスが作成されている

- **テスト名**: test_ai_conversion_history_indexes_created
  - **何をテストするか**: `created_at` と `user_session_id` にインデックスが作成されていること
  - **期待される動作**: `pg_indexes` ビューから2つのインデックスが検出される
- **入力値**:
  - テーブル名: `"ai_conversion_history"`
  - 期待されるインデックス:
    - `idx_ai_conversion_created_at` (created_at DESC)
    - `idx_ai_conversion_session` (user_session_id)
  - **入力データの意味**: パフォーマンス最適化のためのインデックス検証
- **期待される結果**:
  - 2つのインデックスが存在する
  - インデックス名とカラムが一致する
  - **期待結果の理由**: database-schema.sqlで定義されたインデックスが正しく作成される
- **テストの目的**: インデックス作成が正しく実装されることを確認
  - **確認ポイント**: インデックス名、対象カラム、ソート順が設計書と一致しているか
- 🔵 この内容は要件定義書（line 126-128）とdatabase-schema.sql（line 54-68）に基づく

### カテゴリD: マイグレーションロールバックテスト

#### D-1. マイグレーションロールバックが成功する

- **テスト名**: test_alembic_downgrade_success
  - **何をテストするか**: `alembic downgrade -1` コマンドが正常に実行されること
  - **期待される動作**: ロールバックがエラーなく実行され、終了コード0が返される
- **入力値**:
  - コマンド: `alembic downgrade -1`
  - 現在のリビジョン: `alembic_version` テーブルから取得
  - **入力データの意味**: 1つ前のリビジョンに戻すコマンド
- **期待される結果**:
  - 終了コード: 0（成功）
  - 標準出力に "Running downgrade" メッセージが含まれる
  - エラーが発生しない
  - **期待結果の理由**: Alembicのロールバック機能が正常に動作する
- **テストの目的**: ロールバック機能が正常に動作することを確認
  - **確認ポイント**: エラーなく実行され、成功メッセージが出力されるか
- 🔵 この内容は要件定義書（line 72-79, line 410-413）に基づく

#### D-2. ロールバック後にai_conversion_historyテーブルが削除される

- **テスト名**: test_table_deleted_after_downgrade
  - **何をテストするか**: ロールバック後、`ai_conversion_history` テーブルがデータベースから削除されること
  - **期待される動作**: `information_schema.tables` から該当テーブルが検出されない
- **入力値**:
  - テーブル名: `"ai_conversion_history"`
  - **入力データの意味**: ロールバックによりテーブルが削除されたことを確認
- **期待される結果**:
  - `information_schema.tables` から `ai_conversion_history` が検出されない（FALSE）
  - **期待結果の理由**: マイグレーションの `downgrade()` 関数が DROP TABLE を実行する
- **テストの目的**: ロールバックが正しくテーブルを削除することを確認
  - **確認ポイント**: テーブルがデータベースから完全に削除されているか
- 🔵 この内容は要件定義書（line 72-79, line 410-413）に基づく

#### D-3. ロールバック後にalembic_versionテーブルが更新される

- **テスト名**: test_alembic_version_updated_after_downgrade
  - **何をテストするか**: ロールバック後、`alembic_version` テーブルのリビジョンが前のバージョンに戻ること
  - **期待される動作**: `alembic_version` テーブルの `version_num` が1つ前のリビジョンに更新される
- **入力値**:
  - ロールバック前のリビジョンID
  - ロールバック後のリビジョンID（1つ前）
  - **入力データの意味**: マイグレーション履歴が正しく管理されているか確認
- **期待される結果**:
  - `alembic_version` テーブルのリビジョンが1つ前に戻る
  - または、初回マイグレーションの場合は `alembic_version` テーブルが空になる
  - **期待結果の理由**: Alembicがロールバックを正しく記録する
- **テストの目的**: ロールバック後のリビジョン管理が正しく動作することを確認
  - **確認ポイント**: リビジョンIDが正しく更新されているか
- 🔵 この内容は要件定義書（line 72-79, line 299-304）に基づく

### カテゴリE: データベース接続テスト

#### E-1. 非同期セッションが正常に作成され、データベースに接続できる

- **テスト名**: test_database_connection_async_session
  - **何をテストするか**: async_session_makerから非同期セッションを取得し、データベースに接続できること
  - **期待される動作**: SELECT 1クエリが正常に実行される
- **入力値**:
  - なし（セッション取得のみ）
  - **入力データの意味**: データベース接続の確立を確認するための最小クエリ
- **期待される結果**:
  - `SELECT 1` クエリの結果が `1` である
  - 例外が発生しない
  - **期待結果の理由**: データベース接続が正常に確立されている
- **テストの目的**: データベースセッション管理が正しく機能することを確認
  - **確認ポイント**: セッションが正常に作成され、クエリを実行できるか
- 🔵 この内容は要件定義書（line 82-85, line 373-376）と既存テスト（test_db_connection.py line 12-33）に基づく

#### E-2. トランザクション開始機能が正常に動作する

- **テスト名**: test_session_begin_transaction
  - **何をテストするか**: セッションのトランザクション開始機能が正常に動作すること
  - **期待される動作**: `async with session.begin()` でトランザクションブロックが正常に動作する
- **入力値**:
  - なし（トランザクション開始のみ）
  - **入力データの意味**: トランザクション管理機能の検証
- **期待される結果**:
  - トランザクションブロック内でクエリが実行できる
  - トランザクションが正常にコミットされる
  - **期待結果の理由**: SQLAlchemyのトランザクション管理が正しく動作する
- **テストの目的**: トランザクション機能が正常に動作することを確認
  - **確認ポイント**: トランザクションブロックが正常に開始・終了するか
- 🔵 この内容は要件定義書（line 253-262）と既存テスト（test_db_connection.py line 67-90）に基づく

### カテゴリF: CRUD操作テスト（統合テスト）

#### F-1. マイグレーション後のテーブルにレコードを挿入できる

- **テスト名**: test_insert_record_after_migration
  - **何をテストするか**: マイグレーション実行後、`ai_conversion_history` テーブルにレコードを挿入できること
  - **期待される動作**: AIConversionHistoryモデルを使用してレコードを作成し、データベースに保存できる
- **入力値**:
  ```python
  AIConversionHistory(
      input_text="ありがとう",
      converted_text="ありがとうございます",
      politeness_level=PolitenessLevel.POLITE,
      conversion_time_ms=100,
      user_session_id=uuid4()
  )
  ```
  - **入力データの意味**: 実際のユースケースを想定した日本語テキスト
- **期待される結果**:
  - レコードが正常に保存される
  - `id` が自動生成される（整数の正の値）
  - `created_at` が自動設定される（datetime型）
  - **期待結果の理由**: マイグレーションにより作成されたテーブルが正常に動作する
- **テストの目的**: マイグレーション後のテーブルが正常にCRUD操作を受け付けることを確認
  - **確認ポイント**: レコード挿入が成功し、自動生成フィールドが正しく設定されるか
- 🔵 この内容は要件定義書（line 92-106, line 380-382）と既存テスト（test_models.py line 217-252）に基づく

#### F-2. 挿入したレコードを検索できる

- **テスト名**: test_query_inserted_record_after_migration
  - **何をテストするか**: 挿入したレコードをSELECTクエリで取得できること
  - **期待される動作**: 挿入したレコードのIDで検索し、すべてのフィールド値が一致する
- **入力値**:
  - レコードID: 挿入したレコードの `id`
  - **入力データの意味**: 主キーによる検索
- **期待される結果**:
  - レコードが取得できる
  - すべてのフィールド値が挿入時の値と一致する
  - **期待結果の理由**: データベースに正しくデータが保存されている
- **テストの目的**: CRUD操作のRead（読み取り）が正常に動作することを確認
  - **確認ポイント**: 挿入したデータが正確に取得できるか
- 🔵 この内容は要件定義書（line 189-202, line 384-386）と既存テスト（test_models.py line 255-302）に基づく

#### F-3. 複数レコードを挿入し、created_atの降順でソートできる

- **テスト名**: test_insert_multiple_records_and_sort_by_created_at
  - **何をテストするか**: 複数レコードを挿入し、`created_at DESC` でソートできること
  - **期待される動作**: 最新のレコードが先頭に並ぶ
- **入力値**:
  - 3件のレコード（時系列順に挿入）
  - **入力データの意味**: 履歴データの時系列検索を想定
- **期待される結果**:
  - レコードが `created_at` の降順に並ぶ
  - 最新のレコードが先頭に来る
  - **期待結果の理由**: インデックス `idx_ai_conversion_created_at` が正しく機能する
- **テストの目的**: インデックスを使用したソート機能が正常に動作することを確認
  - **確認ポイント**: ソート順が正しく、インデックスが効率的に使用されるか
- 🔵 この内容は要件定義書（line 149, line 189-202）と既存テスト（test_models.py line 356-410）に基づく

#### F-4. user_session_idで絞り込み検索ができる

- **テスト名**: test_filter_by_user_session_id_after_migration
  - **何をテストするか**: `user_session_id` による絞り込み検索が正しく動作すること
  - **期待される動作**: 指定したセッションIDのレコードのみが取得される
- **入力値**:
  - 2つの異なるセッションID（UUID_A, UUID_B）を持つレコード
  - 検索条件: UUID_A
  - **入力データの意味**: セッションごとの履歴検索を想定
- **期待される結果**:
  - UUID_Aのレコードのみが取得される
  - 取得されたレコード数が正確に一致する
  - **期待結果の理由**: インデックス `idx_ai_conversion_session` が正しく機能する
- **テストの目的**: インデックスを使用した絞り込み検索が正常に動作することを確認
  - **確認ポイント**: 絞り込み条件が正しく適用され、インデックスが効率的に使用されるか
- 🔵 この内容は要件定義書（line 150, line 189-202）と既存テスト（test_models.py line 305-353）に基づく

---

## 異常系テストケース（エラーハンドリング）

### カテゴリG: エラーハンドリングテスト

#### G-1. データベースが利用不可の場合、マイグレーション実行が失敗する

- **テスト名**: test_migration_fails_when_database_unavailable
  - **エラーケースの概要**: PostgreSQLコンテナが起動していない、または接続情報が誤っている状態でマイグレーション実行
  - **エラー処理の重要性**: データベースダウン時に適切なエラーメッセージを表示し、デバッグを容易にする（NFR-304）
- **入力値**:
  - 不正なデータベース接続情報（存在しないホスト、ポート、データベース名）
  - **不正な理由**: データベースサーバーが存在しない、または到達不可能
  - **実際の発生シナリオ**: 環境構築時の設定ミス、インフラ障害
- **期待される結果**:
  - マイグレーションが失敗し、終了コード1が返される
  - エラーメッセージに接続情報（ホスト、ポート、データベース名）が含まれる
  - `OperationalError` または接続エラーが発生する
  - **エラーメッセージの内容**: 「データベースに接続できません: postgresql://...」のような分かりやすいメッセージ
  - **システムの安全性**: エラー時にデータベースが破壊されず、ロールバック可能な状態を保つ
- **テストの目的**: データベース接続エラー時の適切なエラーハンドリングを確認
  - **品質保証の観点**: エラーメッセージが開発者にとって有用な情報を含むか
- 🔵 この内容は要件定義書（line 234-251, line 416-420, NFR-304）と既存テスト（test_db_connection.py line 36-64）に基づく

#### G-2. テーブルがすでに存在する場合、マイグレーション実行が失敗する

- **テスト名**: test_migration_fails_when_table_already_exists
  - **エラーケースの概要**: 手動でテーブルを作成済みの状態で `alembic upgrade head` を実行
  - **エラー処理の重要性**: テーブル重複を検出し、データの上書きや破壊を防ぐ
- **入力値**:
  - 事前に手動作成された `ai_conversion_history` テーブル
  - マイグレーションコマンド: `alembic upgrade head`
  - **不正な理由**: マイグレーション管理外でテーブルが作成されている
  - **実際の発生シナリオ**: 手動でのデータベース操作、マイグレーション履歴の不整合
- **期待される結果**:
  - マイグレーションが失敗する
  - エラーメッセージに「テーブルが既に存在する」旨が含まれる
  - データベースが変更されない（ロールバック）
  - **エラーメッセージの内容**: 「relation "ai_conversion_history" already exists」
  - **システムの安全性**: 既存データが保護され、削除されない
- **テストの目的**: テーブル重複エラー時の適切なエラーハンドリングを確認
  - **品質保証の観点**: エラー時に既存データが破壊されないか
- 🔵 この内容は要件定義書（line 253-262）に基づく

#### G-3. マイグレーション後のレコード挿入でNOT NULL制約違反が発生する

- **テスト名**: test_insert_fails_with_not_null_constraint_after_migration
  - **エラーケースの概要**: 必須フィールド（input_text, converted_text）にNoneを設定してレコード挿入
  - **エラー処理の重要性**: データ整合性を保ち、不正なデータの保存を防ぐ（NFR-304）
- **入力値**:
  ```python
  AIConversionHistory(
      input_text=None,  # NOT NULL制約違反
      converted_text="テスト",
      politeness_level=PolitenessLevel.NORMAL
  )
  ```
  - **不正な理由**: `input_text` は NOT NULL 制約があるため、None は許可されない
  - **実際の発生シナリオ**: アプリケーションのバグ、バリデーション処理の欠落
- **期待される結果**:
  - `IntegrityError` が発生する
  - エラーメッセージに制約違反の詳細が含まれる（"null value in column "input_text" violates not-null constraint"）
  - レコードが保存されない（ロールバック）
  - **エラーメッセージの内容**: PostgreSQLのNOT NULL制約エラーメッセージ
  - **システムの安全性**: 不正なデータがデータベースに保存されない
- **テストの目的**: NOT NULL制約が正しく機能し、エラーハンドリングが適切であることを確認
  - **品質保証の観点**: データ整合性が保たれるか
- 🔵 この内容は要件定義書（line 267-286, line 421-426, NFR-304）と既存テスト（test_error_handling.py line 11-46）に基づく

#### G-4. マイグレーション後のレコード挿入で不正なEnum値によるエラーが発生する

- **テスト名**: test_insert_fails_with_invalid_enum_value_after_migration
  - **エラーケースの概要**: `politeness_level` に存在しないEnum値を設定してレコード挿入
  - **エラー処理の重要性**: Enum型バリデーションにより、不正な値の保存を防ぐ
- **入力値**:
  - 不正なEnum値: `"super_polite"` （PolitenessLevelに存在しない）
  - **不正な理由**: Enumに定義されていない値
  - **実際の発生シナリオ**: アプリケーションのバグ、API入力バリデーションの欠落
- **期待される結果**:
  - `ValueError` または `CheckViolationError` が発生する
  - エラーメッセージにEnum値の不一致が含まれる
  - レコードが保存されない
  - **エラーメッセージの内容**: 「invalid input value for enum politeness_level_enum」
  - **システムの安全性**: 不正なEnum値がデータベースに保存されない
- **テストの目的**: Enum型バリデーションが正しく機能することを確認
  - **品質保証の観点**: 不正な値が保存されないか
- 🟡 この内容は要件定義書（line 276-290）に基づくが、実装方法は推測

#### G-5. データベース接続失敗時にOperationalErrorが発生する

- **テスト名**: test_database_connection_error_handling
  - **エラーケースの概要**: 不正なデータベースURLで接続を試み、OperationalErrorを確認
  - **エラー処理の重要性**: データベースダウン時に適切にエラーを報告する（NFR-304）
- **入力値**:
  - 不正なデータベースURL: `"postgresql+asyncpg://invalid:invalid@localhost:9999/invalid"`
  - **不正な理由**: 存在しないホストまたはポート
  - **実際の発生シナリオ**: 環境変数の設定ミス、インフラ障害
- **期待される結果**:
  - `OperationalError` が発生する
  - エラーメッセージに接続失敗の詳細が含まれる
  - **エラーメッセージの内容**: 「Cannot connect to host localhost:9999」
  - **システムの安全性**: アプリケーションが適切にエラーを処理し、クラッシュしない
- **テストの目的**: データベース接続エラー時の適切なエラーハンドリングを確認
  - **品質保証の観点**: エラーが適切にキャッチされ、デバッグ情報が含まれるか
- 🔵 この内容は要件定義書（line 234-251, NFR-304）と既存テスト（test_db_connection.py line 36-64）に基づく

---

## 境界値テストケース（最小値、最大値、null等）

### カテゴリH: マイグレーション冪等性テスト

#### H-1. マイグレーションを複数回実行しても冪等性が保たれる

- **テスト名**: test_migration_idempotency
  - **境界値の意味**: マイグレーション実行回数の境界（1回 vs 複数回）
  - **境界値での動作保証**: 複数回実行してもデータベース状態が一貫している
- **入力値**:
  - `alembic upgrade head` を2回連続で実行
  - **境界値選択の根拠**: Alembicの冪等性機能を検証
  - **実際の使用場面**: デプロイスクリプトの再実行、CI/CDでの複数回実行
- **期待される結果**:
  - 1回目: マイグレーションが実行される
  - 2回目: 「すでに最新のリビジョン」というメッセージが表示され、エラーなく終了
  - テーブル構造が変更されない
  - **境界での正確性**: 複数回実行しても同じ結果になる
  - **一貫した動作**: 2回目以降は何も変更されない
- **テストの目的**: マイグレーションの冪等性を確認
  - **堅牢性の確認**: デプロイ時に誤って複数回実行されても安全か
- 🔵 この内容は要件定義書（line 299-304）に基づく

#### H-2. ロールバック後に再度マイグレーション実行ができる

- **テスト名**: test_migration_reapplication_after_rollback
  - **境界値の意味**: マイグレーション適用状態の境界（未適用 → 適用 → ロールバック → 再適用）
  - **境界値での動作保証**: ロールバック後の再適用が正常に動作する
- **入力値**:
  - 1. `alembic upgrade head` (初回マイグレーション)
  - 2. `alembic downgrade -1` (ロールバック)
  - 3. `alembic upgrade head` (再適用)
  - **境界値選択の根拠**: マイグレーションのライフサイクル全体を検証
  - **実際の使用場面**: マイグレーションの失敗後の再実行、開発中の試行錯誤
- **期待される結果**:
  - 再適用が成功する
  - テーブルが正常に作成される
  - データベース状態が初回マイグレーション後と同じになる
  - **境界での正確性**: ロールバック・再適用サイクルが正しく動作する
  - **一貫した動作**: 何度繰り返しても同じ結果になる
- **テストの目的**: マイグレーションのロールバック・再適用サイクルが正常に動作することを確認
  - **堅牢性の確認**: マイグレーションの試行錯誤が安全に行えるか
- 🔵 この内容は要件定義書（line 72-79, line 410-413）に基づく

#### H-3. 空文字列をinput_textに設定してもレコードを作成できる

- **テスト名**: test_insert_empty_string_after_migration
  - **境界値の意味**: 文字列長の最小値（空文字列 ""）
  - **境界値での動作保証**: 空文字列がNULLとして扱われず、正しく保存される
- **入力値**:
  - `input_text = ""`（空文字列）
  - **境界値選択の根拠**: 空文字列はNULLではないため、NOT NULL制約を満たす
  - **実際の使用場面**: ユーザーが何も入力せずに変換を実行した場合
- **期待される結果**:
  - レコードが正常に作成される
  - `input_text` が空文字列として保存される（NULLではない）
  - NOT NULL制約違反エラーが発生しない
  - **境界での正確性**: 空文字列とNULLが正しく区別される
  - **一貫した動作**: PostgreSQL Text型が空文字列を正しく保存する
- **テストの目的**: 空文字列とNULLの区別が正しく動作することを確認
  - **堅牢性の確認**: 境界値（空文字列）でもエラーが発生しないか
- 🔵 この内容は既存テスト（test_models.py line 542-569）に基づく

#### H-4. conversion_time_ms=0を設定してもレコードを作成できる

- **テスト名**: test_insert_conversion_time_zero_after_migration
  - **境界値の意味**: 整数の最小値（0ミリ秒）
  - **境界値での動作保証**: 0がNULLとして扱われず、正しく保存される
- **入力値**:
  - `conversion_time_ms = 0`
  - **境界値選択の根拠**: 0は有効な値であり、NULLではない
  - **実際の使用場面**: AI変換処理が非常に高速（1ミリ秒未満）だった場合
- **期待される結果**:
  - レコードが正常に作成される
  - `conversion_time_ms` が 0 として保存される（NULLではない）
  - **境界での正確性**: 0とNULLが正しく区別される
  - **一貫した動作**: Integer型が0を正しく保存する
- **テストの目的**: 0とNULLの区別が正しく動作することを確認
  - **堅牢性の確認**: 境界値（0）でもエラーが発生しないか
- 🔵 この内容は要件定義書（line 59）と既存テスト（test_models.py line 604-630）に基づく

#### H-5. 非常に長いテキスト（10,000文字）を設定してもレコードを作成できる

- **テスト名**: test_insert_very_long_text_after_migration
  - **境界値の意味**: 文字列長の最大値（PostgreSQL Text型は無制限だが、実用的な上限を検証）
  - **境界値での動作保証**: 長いテキストが切り捨てられることなく保存される
- **入力値**:
  - `input_text = "あ" * 10000`（10,000文字）
  - **境界値選択の根拠**: 実用的な長文テキストの上限を検証
  - **実際の使用場面**: ユーザーが非常に長い文章を入力した場合（稀だが可能性はある）
- **期待される結果**:
  - レコードが正常に作成される
  - `input_text` の長さが 10,000 文字である
  - テキストが切り捨てられない
  - **境界での正確性**: PostgreSQL Text型が長文を正しく保存する
  - **一貫した動作**: 長文でもパフォーマンスが著しく低下しない
- **テストの目的**: PostgreSQL Text型の長文保存能力を確認
  - **堅牢性の確認**: 極端に長いテキストでもエラーが発生しないか
- 🟡 この内容は妥当な推測（実際の使用では想定外だが、テストとして有用）

---

## テストケース実装時の日本語コメント指針

すべてのテストケース実装時には、以下の日本語コメントを含めてください：

### テストケース開始時のコメント

```python
# 【テスト目的】: [このテストで何を確認するかを日本語で明記]
# 【テスト内容】: [具体的にどのような処理をテストするかを説明]
# 【期待される動作】: [正常に動作した場合の結果を説明]
# 🔵🟡🔴 この内容の信頼性レベルを記載
```

### Given（準備フェーズ）のコメント

```python
# 【テストデータ準備】: [なぜこのデータを用意するかの理由]
# 【初期条件設定】: [テスト実行前の状態を説明]
# 【前提条件確認】: [テスト実行に必要な前提条件を明記]
```

### When（実行フェーズ）のコメント

```python
# 【実際の処理実行】: [どの機能/メソッドを呼び出すかを説明]
# 【処理内容】: [実行される処理の内容を日本語で説明]
# 【実行タイミング】: [なぜこのタイミングで実行するかを説明]
```

### Then（検証フェーズ）のコメント

```python
# 【結果検証】: [何を検証するかを具体的に説明]
# 【期待値確認】: [期待される結果とその理由を説明]
# 【品質保証】: [この検証がシステム品質にどう貢献するかを説明]
```

### 各expectステートメントのコメント

```python
# 【検証項目】: [この検証で確認している具体的な項目]
# 🔵🟡🔴 この内容の信頼性レベルを記載
assert table_exists is True  # 【確認内容】: ai_conversion_historyテーブルが正常に作成されることを確認
```

### セットアップ・クリーンアップのコメント

```python
@pytest.fixture
async def setup_migration():
    # 【テスト前準備】: [各テスト実行前に行う準備作業の説明]
    # 【環境初期化】: [テスト環境をクリーンな状態にする理由と方法]
    yield
    # 【テスト後処理】: [各テスト実行後に行うクリーンアップ作業の説明]
    # 【状態復元】: [次のテストに影響しないよう状態を復元する理由]
```

---

## テストケース実装の実装ファイル構成

### 新規作成ファイル

```
backend/tests/
├── test_migration_generation.py      # カテゴリA: マイグレーション生成テスト
├── test_migration_execution.py       # カテゴリB,C,D: マイグレーション実行・ロールバックテスト
├── test_migration_integration.py     # カテゴリF: CRUD統合テスト
└── test_migration_idempotency.py     # カテゴリH: 冪等性・境界値テスト
```

### 既存ファイルの再利用

```
backend/tests/
├── test_db_connection.py             # カテゴリE: データベース接続テスト（既存）
├── test_error_handling.py            # カテゴリG: エラーハンドリングテスト（既存）
└── conftest.py                       # テストフィクスチャ（既存）
```

---

## テストケースサマリー

### 正常系テストケース: 18件

- カテゴリA（マイグレーション生成）: 3件
- カテゴリB（マイグレーション実行）: 2件
- カテゴリC（テーブル作成確認）: 6件
- カテゴリD（ロールバック）: 3件
- カテゴリE（データベース接続）: 2件
- カテゴリF（CRUD統合テスト）: 4件

### 異常系テストケース: 5件

- カテゴリG（エラーハンドリング）: 5件

### 境界値テストケース: 5件

- カテゴリH（冪等性・境界値）: 5件

### 合計: 28テストケース

---

## 品質判定

### ✅ 高品質

- **テストケース分類**: 正常系・異常系・境界値が網羅されている
  - 正常系: マイグレーション生成、実行、テーブル作成確認、ロールバック、CRUD操作
  - 異常系: データベース接続エラー、テーブル重複エラー、制約違反エラー
  - 境界値: 冪等性、空文字列、0値、長文テキスト
- **期待値定義**: 各テストケースの期待値が明確
  - すべてのテストケースに「期待される結果」と「期待結果の理由」が記載されている
  - エラーケースのエラーメッセージ内容が具体的に定義されている
- **技術選択**: プログラミング言語・テストフレームワークが確定
  - Python 3.11 + pytest 7.4.x + pytest-asyncio 0.25.x
  - 既存テストコード（TASK-0008）との整合性が保たれている
- **実装可能性**: 現在の技術スタックで実現可能
  - 既存のconftest.py、test_db_connection.py、test_models.pyの実装パターンを踏襲
  - Alembic 1.17.1、SQLAlchemy 2.0.36の機能を活用

---

## 次のステップ

✅ テストケース洗い出し完了

**次のお勧めステップ**: `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

---

## 変更履歴

- **2025-11-20**: 初版作成（TDDテストケース洗い出しフェーズ完了）
