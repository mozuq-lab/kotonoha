# テストケース定義書 - TASK-0048: OS標準TTS連携（flutter_tts）

## タスク情報

- **タスクID**: TASK-0048
- **タスク名**: OS標準TTS連携（flutter_tts）
- **タスクタイプ**: TDD
- **推定工数**: 8時間
- **フェーズ**: Phase 3 - Week 11, Day 1
- **依存タスク**: TASK-0038 (文字入力バッファ管理) ✅完了

## 関連文書

- **要件定義書**: [docs/implements/kotonoha/TASK-0048/requirements.md](./requirements.md)
- **EARS要件定義書**: [docs/spec/kotonoha-requirements.md](../../../spec/kotonoha-requirements.md)
- **アーキテクチャ設計**: [docs/design/kotonoha/architecture.md](../../../design/kotonoha/architecture.md)
- **インターフェース定義**: [docs/design/kotonoha/interfaces.dart](../../../design/kotonoha/interfaces.dart)

---

## 開発言語・テストフレームワーク

### プログラミング言語: Dart (Flutter 3.38.1) 🔵

- **言語選択の理由**:
  - 本プロジェクトのフロントエンド全体がFlutter（Dart）で実装されている
  - クロスプラットフォーム対応（iOS/Android）を実現するため
  - 非同期処理（Future/async-await）が標準サポートされており、TTS操作に適している
- **テストに適した機能**:
  - `flutter_test`パッケージによる公式テストサポート
  - 非同期テスト（`async`/`await`）のネイティブサポート
  - モック・スタブ作成が容易（`mocktail`パッケージ利用）

### テストフレームワーク: flutter_test + mocktail 🔵

- **フレームワーク選択の理由**:
  - `flutter_test`: Flutter公式テストフレームワーク、Dartの標準テストライブラリ
  - `mocktail`: 既存プロジェクトで採用済み（`pubspec.yaml` line 65）、型安全なモック作成が可能
  - 既存テストコード（`input_buffer_provider_test.dart`、`emergency_audio_service_test.dart`）と同じパターンを踏襲
- **テスト実行環境**:
  - ローカル開発環境: `flutter test` コマンドで実行
  - CI/CD環境: GitHub Actions等での自動テスト実行を想定
  - テスト対象: ユニットテスト（単体テスト）、ウィジェットテストは後続タスク（TASK-0049）で実装

**信頼性レベル**: 🔵（既存のプロジェクト設定とテストパターンに基づく）

---

## テストケース一覧

### 1. 正常系テストケース（基本的な動作）

#### TC-048-001: TTSServiceが正常に初期化される 🔵

- **テスト名**: TTSServiceが正常に初期化される
  - **何をテストするか**: TTSService.initialize()が成功し、flutter_ttsが正しく初期化されることを確認
  - **期待される動作**: 初期化が成功し、`true`が返される。日本語（ja-JP）と標準速度（1.0）が設定される
- **入力値**: なし（引数なしのメソッド呼び出し）
  - **入力データの意味**: アプリ起動時の初回初期化を想定
- **期待される結果**:
  - `initialize()`が`Future<bool>`として`true`を返す
  - flutter_ttsの`setLanguage("ja-JP")`が1回呼ばれる
  - flutter_ttsの`setSpeechRate(1.0)`が1回呼ばれる
  - **期待結果の理由**: requirements.md「TTSService.initialize()」セクション（119-126行目）に基づく
- **テストの目的**: TTS機能が使用可能な状態になることを確認
  - **確認ポイント**: モック化したflutter_ttsの各メソッドが正しい順序・引数で呼ばれること
- **信頼性レベル**: 🔵（requirements.md、既存テストパターンに基づく）

---

#### TC-048-002: テキストを渡すと読み上げが開始される 🔵

- **テスト名**: テキストを渡すと読み上げが開始される
  - **何をテストするか**: TTSService.speak(text)を呼び出すと、指定したテキストの読み上げが開始されることを確認
  - **期待される動作**: flutter_ttsの`speak(text)`メソッドが呼ばれ、状態が`TTSState.speaking`になる
- **入力値**: `'こんにちは'`（日本語テキスト）
  - **入力データの意味**: ユーザーが文字盤で入力した一般的な挨拶文を想定
- **期待される結果**:
  - flutter_ttsの`speak('こんにちは')`が1回呼ばれる
  - TTSServiceの状態が`TTSState.speaking`になる
  - **期待結果の理由**: requirements.md「TTSService.speak(String text)」セクション（128-139行目）、dataflow.md「読み上げフロー」（201-214行目）に基づく
- **テストの目的**: 基本的な読み上げ機能が正常に動作することを確認
  - **確認ポイント**:
    - モックのspeak()メソッドが正しいテキストで呼ばれること
    - 状態遷移が`idle` → `speaking`に正しく行われること
- **信頼性レベル**: 🔵（requirements.md、dataflow.mdに基づく）

---

#### TC-048-003: 空文字列の読み上げ試行時は何もしない 🔵

- **テスト名**: 空文字列の読み上げ試行時は何もしない
  - **何をテストするか**: 空文字列を渡してspeak()を呼んだ場合、読み上げが開始されず、エラーも発生しないことを確認
  - **期待される動作**: flutter_ttsのspeak()が呼ばれず、状態が`TTSState.idle`のまま維持される
- **入力値**: `''`（空文字列）
  - **入力データの意味**: ユーザーが何も入力していない状態で読み上げボタンを押した場合を想定
- **期待される結果**:
  - flutter_ttsの`speak()`が呼ばれない（`verifyNever`で確認）
  - TTSServiceの状態が`TTSState.idle`のまま
  - エラーが発生しない
  - **期待結果の理由**: requirements.md「TTSService.speak()の制約」（133行目）、「EDGE-3: 空文字列の読み上げ試行」（483-489行目）に基づく
- **テストの目的**: 不正な入力値に対する防御的プログラミングの確認
  - **確認ポイント**:
    - 空文字列のチェックが正しく機能すること
    - エラーにならず安全に処理されること
- **信頼性レベル**: 🔵（requirements.md EDGE-3に基づく）

---

#### TC-048-004: 読み上げ中にstop()を呼ぶと停止する 🔵

- **テスト名**: 読み上げ中にstop()を呼ぶと停止する
  - **何をテストするか**: 読み上げ中にTTSService.stop()を呼ぶと、読み上げが即座に停止することを確認
  - **期待される動作**: flutter_ttsの`stop()`メソッドが呼ばれ、状態が`TTSState.stopped`になる
- **入力値**:
  - 事前に`speak('長いテキストです')`を実行し、読み上げ中の状態にする
  - その後`stop()`を呼び出す
  - **入力データの意味**: ユーザーが読み上げ途中で停止ボタンを押した場合を想定
- **期待される結果**:
  - flutter_ttsの`stop()`が1回呼ばれる
  - TTSServiceの状態が`TTSState.stopped`になる
  - **期待結果の理由**: requirements.md「TTSService.stop()」セクション（141-145行目）、「停止フロー」（217-223行目）に基づく
- **テストの目的**: 読み上げ中断機能が正常に動作することを確認（REQ-403対応）
  - **確認ポイント**:
    - 読み上げ中の状態からstop()を呼んで正しく停止すること
    - 状態遷移が`speaking` → `stopped`に正しく行われること
- **信頼性レベル**: 🔵（requirements.md、REQ-403に基づく）

---

#### TC-048-005: 読み上げ速度を「遅い」に設定できる 🔵

- **テスト名**: 読み上げ速度を「遅い」に設定できる
  - **何をテストするか**: TTSService.setSpeed(TTSSpeed.slow)を呼ぶと、読み上げ速度が0.7に設定されることを確認
  - **期待される動作**: flutter_ttsの`setSpeechRate(0.7)`が呼ばれる
- **入力値**: `TTSSpeed.slow`
  - **入力データの意味**: ユーザーが設定画面で「遅い」速度を選択した場合を想定
- **期待される結果**:
  - flutter_ttsの`setSpeechRate(0.7)`が1回呼ばれる
  - TTSServiceの内部状態（currentSpeed）が`TTSSpeed.slow`になる
  - **期待結果の理由**: requirements.md「TTSService.setSpeed()」セクション（148-158行目）、interfaces.dart「TTSSpeed enum」（298-319行目）に基づく
- **テストの目的**: 読み上げ速度調整機能が正常に動作することを確認（REQ-404対応）
  - **確認ポイント**:
    - `TTSSpeed.slow`の値（0.7）が正しくflutter_ttsに渡されること
    - 状態が正しく保存されること
- **信頼性レベル**: 🔵（requirements.md、interfaces.dartに基づく）

---

#### TC-048-006: 読み上げ速度を「普通」に設定できる 🔵

- **テスト名**: 読み上げ速度を「普通」に設定できる
  - **何をテストするか**: TTSService.setSpeed(TTSSpeed.normal)を呼ぶと、読み上げ速度が1.0に設定されることを確認
  - **期待される動作**: flutter_ttsの`setSpeechRate(1.0)`が呼ばれる
- **入力値**: `TTSSpeed.normal`
  - **入力データの意味**: デフォルト速度、またはユーザーが設定画面で「普通」速度を選択した場合を想定
- **期待される結果**:
  - flutter_ttsの`setSpeechRate(1.0)`が1回呼ばれる
  - TTSServiceの内部状態（currentSpeed）が`TTSSpeed.normal`になる
  - **期待結果の理由**: requirements.md「TTSService.setSpeed()」セクション、interfaces.dartに基づく
- **テストの目的**: デフォルト速度設定が正常に動作することを確認
  - **確認ポイント**: 標準速度（1.0）が正しく設定されること
- **信頼性レベル**: 🔵（requirements.md、interfaces.dartに基づく）

---

#### TC-048-007: 読み上げ速度を「速い」に設定できる 🔵

- **テスト名**: 読み上げ速度を「速い」に設定できる
  - **何をテストするか**: TTSService.setSpeed(TTSSpeed.fast)を呼ぶと、読み上げ速度が1.3に設定されることを確認
  - **期待される動作**: flutter_ttsの`setSpeechRate(1.3)`が呼ばれる
- **入力値**: `TTSSpeed.fast`
  - **入力データの意味**: ユーザーが設定画面で「速い」速度を選択した場合を想定
- **期待される結果**:
  - flutter_ttsの`setSpeechRate(1.3)`が1回呼ばれる
  - TTSServiceの内部状態（currentSpeed）が`TTSSpeed.fast`になる
  - **期待結果の理由**: requirements.md「TTSService.setSpeed()」セクション、interfaces.dartに基づく
- **テストの目的**: 高速読み上げ設定が正常に動作することを確認（REQ-404対応）
  - **確認ポイント**: `TTSSpeed.fast`の値（1.3）が正しくflutter_ttsに渡されること
- **信頼性レベル**: 🔵（requirements.md、interfaces.dartに基づく）

---

#### TC-048-008: 状態が正しく遷移する（idle→speaking→completed） 🔵

- **テスト名**: 状態が正しく遷移する（idle→speaking→completed）
  - **何をテストするか**: 読み上げ開始から完了までの状態遷移が正しく行われることを確認
  - **期待される動作**: `idle` → `speaking` → `completed`の順に状態が遷移する
- **入力値**:
  - 初期状態: `TTSState.idle`
  - `speak('テスト')`を実行
  - flutter_ttsのモックで完了コールバックを発火
  - **入力データの意味**: 正常な読み上げサイクル全体を想定
- **期待される結果**:
  - 初期状態が`TTSState.idle`
  - speak()呼び出し直後が`TTSState.speaking`
  - 読み上げ完了後が`TTSState.completed`
  - 完了後、自動的に`TTSState.idle`に戻る
  - **期待結果の理由**: requirements.md「TTSService state (TTSState)」セクション（168-176行目）に基づく
- **テストの目的**: 状態管理が正しく機能することを確認
  - **確認ポイント**:
    - 各状態遷移のタイミングが正確であること
    - 状態遷移フローが要件通りであること
- **信頼性レベル**: 🔵（requirements.md「状態遷移」に基づく）

---

#### TC-048-009: 読み上げ完了後にidleに戻る 🔵

- **テスト名**: 読み上げ完了後にidleに戻る
  - **何をテストするか**: 読み上げが完了すると、状態が自動的に`idle`に戻ることを確認
  - **期待される動作**: `completed`状態の後、自動的に`idle`に遷移する
- **入力値**:
  - `speak('短いテキスト')`を実行
  - flutter_ttsのモックで完了コールバックを発火
  - **入力データの意味**: 短い文章の読み上げが正常終了した場合を想定
- **期待される結果**:
  - 読み上げ完了時に`TTSState.completed`になる
  - その後、`TTSState.idle`に戻る
  - **期待結果の理由**: requirements.md「状態遷移」（168-176行目）、dataflow.md「読み上げフロー」に基づく
- **テストの目的**: 読み上げ完了後に次の読み上げが可能な状態になることを確認
  - **確認ポイント**: 状態が自動的にリセットされ、次の操作が可能になること
- **信頼性レベル**: 🔵（requirements.md、dataflow.mdに基づく）

---

#### TC-048-010: 複数回のspeak()呼び出しで連続読み上げができる 🔵

- **テスト名**: 複数回のspeak()呼び出しで連続読み上げができる
  - **何をテストするか**: 読み上げ完了後、再度speak()を呼ぶと新しいテキストの読み上げが開始されることを確認
  - **期待される動作**: 1回目の読み上げ完了後、2回目のspeak()が正常に実行される
- **入力値**:
  - 1回目: `speak('最初のテキスト')`
  - 完了後
  - 2回目: `speak('次のテキスト')`
  - **入力データの意味**: ユーザーが続けて複数の文章を読み上げる場合を想定
- **期待される結果**:
  - flutter_ttsの`speak()`が合計2回呼ばれる
  - 1回目: `speak('最初のテキスト')`
  - 2回目: `speak('次のテキスト')`
  - **期待結果の理由**: requirements.md「パターン1: 文字入力からの読み上げ」（363-377行目）に基づく
- **テストの目的**: 連続した読み上げ操作が正常に動作することを確認
  - **確認ポイント**:
    - 各読み上げが独立して正しく実行されること
    - 状態が正しくリセットされること
- **信頼性レベル**: 🔵（requirements.md使用例に基づく）

---

### 2. 異常系テストケース（エラーハンドリング）

#### TC-048-011: TTS初期化失敗時もアプリはクラッシュしない 🔵

- **テスト名**: TTS初期化失敗時もアプリはクラッシュしない
  - **エラーケースの概要**: flutter_ttsの初期化が失敗した場合のエラーハンドリングを確認
  - **エラー処理の重要性**: 初期化失敗時もアプリの基本機能（文字盤+テキスト表示）は継続動作する必要がある（NFR-301）
- **入力値**:
  - flutter_ttsのモックで`setLanguage()`が例外をスローするように設定
  - **不正な理由**: OSのTTS機能が無効化されている、またはサポートされていない環境を想定
  - **実際の発生シナリオ**:
    - 古いOSバージョンでTTS機能が利用不可
    - 端末の設定でTTSが無効化されている
    - プラットフォーム非対応（一部のエミュレータ等）
- **期待される結果**:
  - `initialize()`が`false`を返す
  - 例外がスローされず、安全に処理される
  - エラーメッセージ（errorMessage）が設定される（例: "TTS初期化に失敗しました"）
  - **エラーメッセージの内容**: ユーザーに分かりやすく、「音声読み上げ機能が使えません」と通知
  - **システムの安全性**: 基本機能（文字盤+テキスト表示）は継続動作する
  - **期待結果の理由**: requirements.md「EDGE-4: TTS初期化失敗」（492-502行目）、NFR-301に基づく
- **テストの目的**: エラーハンドリングの確認
  - **品質保証の観点**:
    - システムの堅牢性を保証
    - ユーザー体験の継続性を確保
    - エラー時も安全な状態を維持
- **信頼性レベル**: 🔵（requirements.md EDGE-4、NFR-301に基づく）

---

#### TC-048-012: 読み上げエラー時もアプリはクラッシュしない 🔵

- **テスト名**: 読み上げエラー時もアプリはクラッシュしない
  - **エラーケースの概要**: 読み上げ中にエラーが発生した場合のエラーハンドリングを確認
  - **エラー処理の重要性**: 読み上げ失敗時もテキスト表示は継続し、履歴に保存される必要がある（EDGE-004）
- **入力値**:
  - flutter_ttsのモックで`speak()`が例外をスローするように設定
  - **不正な理由**: 音声データの破損、OSのTTSエンジンの予期しないエラーを想定
  - **実際の発生シナリオ**:
    - 長時間動作中にメモリ不足
    - OSのTTSサービスが一時的に応答しない
    - 特定の文字列でTTSエンジンがクラッシュ（まれなケース）
- **期待される結果**:
  - 例外がキャッチされ、状態が`TTSState.error`になる
  - エラーメッセージが設定される（例: "読み上げに失敗しました"）
  - アプリはクラッシュせず、テキスト表示は継続
  - **エラーメッセージの内容**: "読み上げに失敗しましたが、テキストは表示されています"
  - **システムの安全性**:
    - テキスト表示は継続
    - 履歴には保存される（音声なしでも記録）
    - 次の操作が可能
  - **期待結果の理由**: requirements.md「エラー1: TTS読み上げ中のエラー」（517-539行目）、EDGE-004に基づく
- **テストの目的**: エラーハンドリングの確認
  - **品質保証の観点**:
    - システムの可用性を保証
    - データ損失を防止（履歴保存）
    - ユーザー通知の適切性
- **信頼性レベル**: 🔵（requirements.md エラー1、EDGE-004に基づく）

---

#### TC-048-013: 読み上げ中でない状態でstop()を呼んでもエラーにならない 🟡

- **テスト名**: 読み上げ中でない状態でstop()を呼んでもエラーにならない
  - **エラーケースの概要**: idle状態でstop()を呼び出した場合の安全処理を確認
  - **エラー処理の重要性**: ユーザーの誤操作（連続タップ等）に対する防御的プログラミング
- **入力値**:
  - TTSServiceが`idle`状態
  - `stop()`を呼び出す
  - **不正な理由**: 読み上げ中でないのにstop()を呼ぶのは論理的に不正
  - **実際の発生シナリオ**:
    - ユーザーが停止ボタンを連続でタップ
    - 読み上げ完了直後に停止ボタンを押す（タイミングのずれ）
- **期待される結果**:
  - エラーが発生しない（`returnsNormally`）
  - flutter_ttsの`stop()`は呼ばれても問題ない（冪等性）
  - 状態は`idle`のまま変化しない
  - **エラーメッセージの内容**: エラーメッセージは表示されない（正常動作）
  - **システムの安全性**: 何も起こらず、次の操作が可能
  - **期待結果の理由**: 既存テスト（input_buffer_provider_test.dart TC-013）の安全処理パターンを踏襲
- **テストの目的**: エラーハンドリングの確認
  - **品質保証の観点**:
    - 誤操作に対する堅牢性
    - 予期しない状態遷移の防止
- **信頼性レベル**: 🟡（既存テストパターンから類推、requirements.mdには明示的記載なし）

---

#### TC-048-014: 初期化前にspeak()を呼んでもエラーハンドリングされる 🟡

- **テスト名**: 初期化前にspeak()を呼んでもエラーハンドリングされる
  - **エラーケースの概要**: initialize()を呼ばずにspeak()を呼び出した場合のエラーハンドリングを確認
  - **エラー処理の重要性**: 初期化順序の誤りに対する防御
- **入力値**:
  - `initialize()`を呼ばない
  - 直接`speak('テスト')`を呼び出す
  - **不正な理由**: TTSServiceが初期化されていない状態での使用
  - **実際の発生シナリオ**:
    - 実装ミス（初期化忘れ）
    - 非同期初期化の完了前に読み上げが呼ばれる
- **期待される結果**:
  - エラーが発生する、または何も起こらない（安全に無視）
  - 状態が`TTSState.error`になるか、`idle`のまま
  - エラーメッセージが設定される（例: "TTSが初期化されていません"）
  - **エラーメッセージの内容**: "音声読み上げの準備ができていません"
  - **システムの安全性**: アプリはクラッシュせず、テキスト表示は継続
  - **期待結果の理由**: NFR-301（基本機能は継続動作）の原則を適用
- **テストの目的**: エラーハンドリングの確認
  - **品質保証の観点**:
    - 初期化順序の誤りに対する堅牢性
    - 開発者エラーの早期検出
- **信頼性レベル**: 🟡（NFR-301から類推、requirements.mdには明示的記載なし）

---

### 3. 境界値テストケース（最小値、最大値、null等）

#### TC-048-015: 1文字のテキストが正常に読み上げられる 🔵

- **テスト名**: 1文字のテキストが正常に読み上げられる
  - **境界値の意味**: テキスト長の最小値（1文字）での動作確認
  - **境界値での動作保証**: 極端に短いテキストでも正常に読み上げられることを保証
- **入力値**: `'あ'`（1文字）
  - **境界値選択の根拠**: 有効なテキストの最小単位
  - **実際の使用場面**: ユーザーが1文字だけ入力して読み上げる場合
- **期待される結果**:
  - flutter_ttsの`speak('あ')`が1回呼ばれる
  - 状態が`TTSState.speaking`になる
  - **境界での正確性**: 1文字でも正しく読み上げ処理が開始される
  - **一貫した動作**: 複数文字の場合と同じ処理フローが実行される
  - **期待結果の理由**: requirements.md「基本的な使用パターン」に基づく
- **テストの目的**: 境界条件の確認
  - **堅牢性の確認**: 最小単位のテキストでも安定動作すること
- **信頼性レベル**: 🔵（requirements.md使用例から導出）

---

#### TC-048-016: 1000文字のテキストが正常に読み上げられる 🔵

- **テスト名**: 1000文字のテキストが正常に読み上げられる
  - **境界値の意味**: 入力バッファの最大文字数（1000文字）での動作確認
  - **境界値での動作保証**: 最大長のテキストでも正常に読み上げられることを保証
- **入力値**: `'あ' * 1000`（1000文字の日本語テキスト）
  - **境界値選択の根拠**: TASK-0038で定義された入力バッファの最大文字数（1000文字）
  - **実際の使用場面**: ユーザーが長文を入力して読み上げる場合
- **期待される結果**:
  - flutter_ttsの`speak()`が呼ばれる（引数は1000文字のテキスト）
  - 状態が`TTSState.speaking`になる
  - エラーが発生しない
  - **境界での正確性**: 1000文字でも正しく読み上げ処理が開始される
  - **一貫した動作**: 短いテキストと同じ処理フローが実行される
  - **期待結果の理由**: requirements.md「TTSService.speak()の制約」（133行目: 最大1000文字）、TASK-0038の入力バッファ制限に基づく
- **テストの目的**: 境界条件の確認
  - **堅牢性の確認**: 最大長のテキストでも安定動作すること
- **信頼性レベル**: 🔵（requirements.md制約、TASK-0038仕様に基づく）

---

#### TC-048-017: 特殊文字（絵文字、記号）が含まれるテキストの読み上げ 🟡

- **テスト名**: 特殊文字（絵文字、記号）が含まれるテキストの読み上げ
  - **境界値の意味**: 通常の文字以外の特殊文字が含まれる場合の動作確認
  - **境界値での動作保証**: 特殊文字を含むテキストでもエラーにならないことを保証
- **入力値**: `'こんにちは😊！？'`（絵文字と記号を含むテキスト）
  - **境界値選択の根拠**: ユーザーが絵文字や記号を入力する可能性がある
  - **実際の使用場面**: カジュアルなコミュニケーションで絵文字を使う場合
- **期待される結果**:
  - flutter_ttsの`speak()`が呼ばれる
  - エラーが発生しない（TTSエンジンが絵文字を無視または読み飛ばす）
  - 状態が`TTSState.speaking`になる
  - **境界での正確性**: 特殊文字を含んでも読み上げ処理が開始される
  - **一貫した動作**: TTSエンジンの仕様に依存するが、エラーにならないこと
  - **期待結果の理由**: 既存テスト（input_buffer_provider_test.dart TC-026〜028）の特殊文字テストパターンを踏襲
- **テストの目的**: 境界条件の確認
  - **堅牢性の確認**: 特殊文字を含むテキストでもクラッシュしないこと
- **信頼性レベル**: 🟡（既存テストパターンから類推、TTSエンジンの動作はプラットフォーム依存）

---

#### TC-048-018: 読み上げ速度の境界値（0.7、1.0、1.3）が正しく設定される 🔵

- **テスト名**: 読み上げ速度の境界値（0.7、1.0、1.3）が正しく設定される
  - **境界値の意味**: 読み上げ速度の最小値（0.7）、標準値（1.0）、最大値（1.3）での動作確認
  - **境界値での動作保証**: 定義された速度範囲内で正確に設定されることを保証
- **入力値**:
  - `TTSSpeed.slow`（0.7）
  - `TTSSpeed.normal`（1.0）
  - `TTSSpeed.fast`（1.3）
  - **境界値選択の根拠**: interfaces.dart「TTSSpeed enum」（298-319行目）で定義された値
  - **実際の使用場面**: ユーザーが設定画面で各速度を選択する場合
- **期待される結果**:
  - `TTSSpeed.slow`: `setSpeechRate(0.7)`が呼ばれる
  - `TTSSpeed.normal`: `setSpeechRate(1.0)`が呼ばれる
  - `TTSSpeed.fast`: `setSpeechRate(1.3)`が呼ばれる
  - **境界での正確性**: 各enumの値が正確にdouble値に変換される
  - **一貫した動作**: `TTSSpeed.value`ゲッターが正しく機能する
  - **期待結果の理由**: interfaces.dart「TTSSpeed.value」（308-318行目）、requirements.md「速度値」（150-153行目）に基づく
- **テストの目的**: 境界条件の確認
  - **堅牢性の確認**: 定義された速度範囲で正確に動作すること
- **信頼性レベル**: 🔵（interfaces.dart、requirements.mdに基づく）

---

#### TC-048-019: 読み上げ中に新しいテキストの読み上げを開始すると前の読み上げが停止する 🔵

- **テスト名**: 読み上げ中に新しいテキストの読み上げを開始すると前の読み上げが停止する
  - **境界値の意味**: 状態遷移の境界（speaking状態でのspeak()呼び出し）での動作確認
  - **境界値での動作保証**: 読み上げ中の新規読み上げリクエストが正しく処理されることを保証
- **入力値**:
  - 1回目: `speak('長いテキストA...')`（読み上げ中状態にする）
  - 2回目: `speak('新しいテキストB')`（読み上げ中に再度呼び出す）
  - **境界値選択の根拠**: requirements.md「EDGE-2: 読み上げ中に新しいテキストを読み上げ」（468-481行目）
  - **実際の使用場面**: ユーザーが読み上げ中に別の文章の読み上げをリクエストする場合
- **期待される結果**:
  - flutter_ttsの`stop()`が1回呼ばれる（前の読み上げを停止）
  - その後、flutter_ttsの`speak('新しいテキストB')`が呼ばれる
  - 状態が`speaking`のまま維持される（一度`stopped`を経由するか、直接`speaking`のまま）
  - **境界での正確性**: 前の読み上げが確実に停止し、新しい読み上げが開始される
  - **一貫した動作**: requirements.md「制約」（134行目: 読み上げ中に再度呼び出された場合は前の読み上げを停止してから新規読み上げ）に基づく
  - **期待結果の理由**: requirements.md EDGE-2、「TTSService.speak()の制約」に基づく
- **テストの目的**: 境界条件の確認
  - **堅牢性の確認**: 状態遷移の境界で正しく処理されること
- **信頼性レベル**: 🔵（requirements.md EDGE-2に基づく）

---

#### TC-048-020: nullを渡してspeak()を呼んでもエラーにならない 🟡

- **テスト名**: nullを渡してspeak()を呼んでもエラーにならない
  - **境界値の意味**: null入力に対する防御的プログラミングの確認
  - **境界値での動作保証**: null入力でもクラッシュせず、安全に処理されることを保証
- **入力値**: `null`
  - **境界値選択の根拠**: Dartのnull safety以前のコードとの互換性、または実装ミスへの防御
  - **実際の使用場面**: 実装ミス、または外部からの不正な入力
- **期待される結果**:
  - エラーが発生しない、または適切にハンドリングされる
  - flutter_ttsの`speak()`が呼ばれない（空文字列と同じ扱い）
  - 状態が`idle`のまま
  - **境界での正確性**: nullを空文字列として扱う、または無視する
  - **一貫した動作**: 空文字列（TC-048-003）と同様の動作
  - **期待結果の理由**: Dartのnull safetyにより、通常はコンパイル時にエラーになるが、念のための防御テスト
- **テストの目的**: 境界条件の確認
  - **堅牢性の確認**: 予期しない入力に対する堅牢性
- **信頼性レベル**: 🟡（null safetyにより通常は不要だが、防御的プログラミングとして推奨）

**注**: Dart 3.x（Null Safety）では、`String text`はnon-nullableなため、このテストケースは実装時に`String? text`とするか、スキップする可能性があります。

---

### 4. 状態管理テストケース（Riverpod StateNotifier） 🔵

#### TC-048-021: TTSProviderが正しく定義されている 🔵

- **テスト名**: TTSProviderが正しく定義されている
  - **何をテストするか**: ttsProviderがStateNotifierProvider型であることを確認
  - **期待される動作**: Providerから状態を読み取れること
- **入力値**: なし（Providerの型確認）
  - **入力データの意味**: 既存テスト（input_buffer_provider_test.dart TC-031）のパターンを踏襲
- **期待される結果**:
  - `container.read(ttsProvider)`が状態オブジェクトを返す
  - 状態オブジェクトが`TTSServiceState`型である
  - **期待結果の理由**: architecture.md「Riverpod 2.x必須」、既存テストパターンに基づく
- **テストの目的**: Providerの定義確認
  - **確認ポイント**: Riverpodの状態管理が正しく設定されていること
- **信頼性レベル**: 🔵（既存テストパターンに基づく）

---

#### TC-048-022: 状態変更がRiverpod stateに即座に反映される 🔵

- **テスト名**: 状態変更がRiverpod stateに即座に反映される
  - **何をテストするか**: speak()呼び出し時に状態変更がリスナーに通知されることを確認
  - **期待される動作**: container.listen()で状態変更をキャプチャできる
- **入力値**:
  - `container.listen(ttsProvider, ...)`で状態監視
  - `speak('テスト')`を呼び出す
  - **入力データの意味**: 既存テスト（input_buffer_provider_test.dart TC-011）のパターンを踏襲
- **期待される結果**:
  - 状態変更リストに`idle` → `speaking`の遷移が記録される
  - **期待結果の理由**: NFR-003（100ms以内応答）、dataflow.mdに基づく
- **テストの目的**: 状態通知の確認
  - **確認ポイント**: Riverpodの状態通知機構が正しく機能すること
- **信頼性レベル**: 🔵（既存テストパターンに基づく）

---

### 5. パフォーマンステストケース 🟡

#### TC-048-023: 読み上げ開始まで1秒以内（モック環境） 🟡

- **テスト名**: 読み上げ開始まで1秒以内（モック環境）
  - **何をテストするか**: speak()呼び出しから読み上げ開始までの時間が1秒以内であることを確認
  - **期待される動作**: モック環境でのレスポンスタイムを測定
- **入力値**:
  - `speak('テスト')`を呼び出す
  - 開始時刻と完了時刻を記録
  - **入力データの意味**: NFR-001（TTS読み上げ開始1秒以内）の要件検証
- **期待される結果**:
  - speak()呼び出しから状態が`speaking`になるまでの時間が1000ms以内
  - **期待結果の理由**: requirements.md「パフォーマンス要件」（271-278行目）、NFR-001に基づく
- **テストの目的**: パフォーマンス要件の確認
  - **確認ポイント**:
    - モック環境では即座に完了するはずだが、実装のオーバーヘッドを測定
    - 実機テストでの1秒以内を保証するための事前検証
- **信頼性レベル**: 🟡（モック環境での測定は参考値、実機テストが必要）

**注**: このテストケースはモック環境での測定のため、実際のパフォーマンス保証には実機での統合テストが必要です（AC-008参照）。

---

### 6. プラットフォーム互換性テストケース 🟡

#### TC-048-024: iOS/Androidプラットフォーム検出が正しく動作する 🟡

- **テスト名**: iOS/Androidプラットフォーム検出が正しく動作する
  - **何をテストするか**: Platform.isIOS / Platform.isAndroidの判定が正しく行われることを確認
  - **期待される動作**: プラットフォームに応じた初期化処理が実行される
- **入力値**:
  - テスト環境（通常はLinux/macOS）でのプラットフォーム判定
  - **入力データの意味**: requirements.md「プラットフォーム要件」（286-290行目）に基づく
- **期待される結果**:
  - テスト環境でのプラットフォーム判定が正しく行われる
  - iOS/Android固有の設定が適用される（モック経由で確認）
  - **期待結果の理由**: requirements.md「プラットフォーム要件」、NFR-401に基づく
- **テストの目的**: プラットフォーム互換性の確認
  - **確認ポイント**: プラットフォーム固有のコードパスが正しく実行されること
- **信頼性レベル**: 🟡（テスト環境とターゲット環境の違いにより、実機テストが必要）

**注**: このテストケースはユニットテストでは限定的な検証となり、実際のiOS/Android実機での統合テストが必要です（AC-007参照）。

---

### 7. モック・スタブテストケース 🔵

#### TC-048-025: FlutterTtsがモック化できる 🔵

- **テスト名**: FlutterTtsがモック化できる
  - **何をテストするか**: mocktailを使ってFlutterTtsをモック化し、TTSServiceに注入できることを確認
  - **期待される動作**: モックが正しく注入され、メソッド呼び出しをモニタリングできる
- **入力値**:
  - `MockFlutterTts`を作成
  - `TTSService(tts: mockFlutterTts)`で注入
  - **入力データの意味**: 既存テスト（emergency_audio_service_test.dart TC-047-006）のパターンを踏襲
- **期待される結果**:
  - モックが正しく注入される
  - `verify(() => mockFlutterTts.speak(any()))`で呼び出しを検証できる
  - **期待結果の理由**: 既存のテストパターンに基づく
- **テストの目的**: テスト基盤の確認
  - **確認ポイント**: モック化が正しく機能すること
- **信頼性レベル**: 🔵（既存テストパターンに基づく）

---

#### TC-048-026: FlutterTtsの各メソッドが正しい順序で呼ばれる 🔵

- **テスト名**: FlutterTtsの各メソッドが正しい順序で呼ばれる
  - **何をテストするか**: initialize()やspeak()の呼び出し時に、FlutterTtsのメソッドが正しい順序で呼ばれることを確認
  - **期待される動作**: setLanguage → setSpeechRate → speak の順で呼び出される
- **入力値**:
  - `initialize()`を呼び出す
  - `speak('テスト')`を呼び出す
  - **入力データの意味**: 既存テスト（emergency_audio_service_test.dart TC-047-007）のパターンを踏襲
- **期待される結果**:
  - `verifyInOrder([...])`で順序を確認
  - 初期化時: `setLanguage("ja-JP")` → `setSpeechRate(1.0)`
  - 読み上げ時: `speak(text)`
  - **期待結果の理由**: requirements.md「初期化フロー」（189-199行目）に基づく
- **テストの目的**: 初期化シーケンスの確認
  - **確認ポイント**: メソッド呼び出しの順序が正しいこと
- **信頼性レベル**: 🔵（requirements.md、既存テストパターンに基づく）

---

### 8. エッジケーステストケース（追加） 🟡

#### TC-048-027: 音量0（ミュート）時の警告表示確認 🟡

- **テスト名**: 音量0（ミュート）時の警告表示確認
  - **何をテストするか**: checkVolume()がfalseを返す場合、適切な警告が表示されることを確認
  - **期待される動作**: 音量0の場合、読み上げが開始されず、警告メッセージが設定される
- **入力値**:
  - `checkVolume()`がfalseを返すようにモック設定
  - `speak('テスト')`を呼び出す
  - **入力データの意味**: requirements.md「EDGE-1: 音量0（ミュート）での読み上げ試行」（452-466行目）、EDGE-202に基づく
- **期待される結果**:
  - `checkVolume()`が呼ばれる
  - 音量0の場合、flutter_ttsの`speak()`が呼ばれない
  - 警告メッセージが設定される（例: "音量が0です。音量を上げてください"）
  - 状態が`idle`のまま（または`error`状態）
  - **期待結果の理由**: requirements.md EDGE-1、EDGE-202に基づく
- **テストの目的**: エッジケースのエラーハンドリング確認
  - **確認ポイント**:
    - 音量チェックが正しく機能すること
    - ユーザーに適切な警告が表示されること
- **信頼性レベル**: 🟡（requirements.mdに記載はあるが、checkVolume()の実装詳細はプラットフォーム依存）

**注**: checkVolume()の実装はプラットフォーム固有のAPIに依存するため、実機テストが必要です。

---

#### TC-048-028: 連続したstop()呼び出しが安全に処理される 🟡

- **テスト名**: 連続したstop()呼び出しが安全に処理される
  - **何をテストするか**: stop()を連続で呼び出してもエラーにならないことを確認
  - **期待される動作**: 冪等性が保たれ、エラーが発生しない
- **入力値**:
  - `speak('テスト')`を呼び出す（読み上げ中状態にする）
  - `stop()`を2回連続で呼び出す
  - **入力データの意味**: ユーザーの誤操作（連続タップ）を想定
- **期待される結果**:
  - flutter_ttsの`stop()`が複数回呼ばれても問題ない
  - エラーが発生しない
  - 状態が`stopped`のまま維持される
  - **期待結果の理由**: 防御的プログラミングの原則
- **テストの目的**: エッジケースの安全性確認
  - **確認ポイント**: 連続操作に対する堅牢性
- **信頼性レベル**: 🟡（requirements.mdには明示的記載なし、防御的プログラミングとして推奨）

---

### 9. リソース管理テストケース 🔵

#### TC-048-029: リソース解放時にFlutterTtsがdisposeされる 🔵

- **テスト名**: リソース解放時にFlutterTtsがdisposeされる
  - **何をテストするか**: TTSService.dispose()を呼ぶと、FlutterTtsのdispose()が呼ばれることを確認
  - **期待される動作**: リソースが適切に解放される
- **入力値**:
  - `dispose()`を呼び出す
  - **入力データの意味**: 既存テスト（emergency_audio_service_test.dart TC-047-009）のパターンを踏襲
- **期待される結果**:
  - flutter_ttsの`dispose()`が1回呼ばれる
  - **期待結果の理由**: Flutterのリソース管理ベストプラクティス
- **テストの目的**: リソース管理の確認
  - **確認ポイント**: メモリリークを防止するための適切なリソース解放
- **信頼性レベル**: 🔵（既存テストパターンに基づく）

---

## テストケース実装時の注意事項

### Given-When-Then パターンの適用 🔵

すべてのテストケースは以下のパターンで実装してください：

```dart
test('TC-048-XXX: テスト名', () async {
  // 【テスト目的】: このテストで何を確認するかを日本語で明記
  // 【テスト内容】: 具体的にどのような処理をテストするかを説明
  // 【期待される動作】: 正常に動作した場合の結果を説明
  // 🔵🟡🔴 この内容の信頼性レベルを記載

  // Given: テストデータ準備
  // 【テストデータ準備】: なぜこのデータを用意するかの理由
  final mockFlutterTts = MockFlutterTts();
  final service = TTSService(tts: mockFlutterTts);

  // When: 実際の処理実行
  // 【実際の処理実行】: どの機能/メソッドを呼び出すかを説明
  await service.speak('テスト');

  // Then: 結果検証
  // 【結果検証】: 何を検証するかを具体的に説明
  verify(() => mockFlutterTts.speak('テスト')).called(1); // 【確認内容】: speak()が1回呼ばれることを確認
  expect(service.state, TTSState.speaking); // 【確認内容】: 状態がspeakingになることを確認
});
```

### モック設定パターン 🔵

```dart
setUp(() {
  // 【テスト前準備】: 各テストが独立して実行できるよう、クリーンな状態から開始
  mockFlutterTts = MockFlutterTts();

  // モックのデフォルト動作を設定
  when(() => mockFlutterTts.setLanguage(any())).thenAnswer((_) async => 1);
  when(() => mockFlutterTts.setSpeechRate(any())).thenAnswer((_) async => 1);
  when(() => mockFlutterTts.speak(any())).thenAnswer((_) async => 1);
  when(() => mockFlutterTts.stop()).thenAnswer((_) async => 1);

  service = TTSService(tts: mockFlutterTts);
});

tearDown(() {
  // 【テスト後処理】: ProviderContainerを破棄し、メモリリークを防ぐ
  service.dispose();
});
```

---

## 受け入れ基準とテストケースの対応

### 機能要件の受け入れ基準 🔵

| AC ID | 受け入れ基準 | 対応テストケース |
|-------|-------------|----------------|
| AC-001 | TTSServiceが正常に初期化される | TC-048-001 |
| AC-002 | テキストを渡すと読み上げが開始される | TC-048-002 |
| AC-003 | 読み上げ中にstop()を呼ぶと停止する | TC-048-004 |
| AC-004 | 速度設定が正しく反映される | TC-048-005, TC-048-006, TC-048-007, TC-048-018 |
| AC-005 | 空文字列の読み上げ試行時は何もしない | TC-048-003 |
| AC-006 | 状態が正しく遷移する（idle→speaking→completed） | TC-048-008, TC-048-009 |
| AC-007 | iOS/Android両プラットフォームで動作する | TC-048-024（要実機テスト） |

### 非機能要件の受け入れ基準 🔵

| AC ID | 受け入れ基準 | 対応テストケース |
|-------|-------------|----------------|
| AC-008 | 読み上げ開始まで1秒以内 | TC-048-023（要実機テスト） |
| AC-009 | TTS初期化失敗時も基本機能は動作する | TC-048-011 |
| AC-010 | 読み上げエラー時もアプリはクラッシュしない | TC-048-012 |
| AC-011 | オフライン環境で動作する | TC-048-001〜010（OS標準TTSのため保証） |

### エッジケースの受け入れ基準 🟡

| AC ID | 受け入れ基準 | 対応テストケース |
|-------|-------------|----------------|
| AC-012 | 音量0時の警告表示（checkVolume実装） | TC-048-027 |
| AC-013 | 読み上げ中に新規読み上げを開始すると前の読み上げが停止 | TC-048-019 |
| AC-014 | 長いテキスト（1000文字）も正常に読み上げられる | TC-048-016 |

---

## テストカバレッジ目標 🔵

### 全体カバレッジ: 80%以上 🔵

- **要件網羅率**: 90%以上
  - REQ-401, REQ-403, REQ-404の主要要件をすべてカバー
  - EDGE-004, EDGE-202のエッジケースをカバー
  - NFR-001, NFR-301の非機能要件をカバー
- **機能網羅率**: 95%以上
  - initialize(), speak(), stop(), setSpeed(), checkVolume()のすべてのメソッドをカバー
  - 状態遷移パターンをすべてカバー
  - エラーハンドリングパスをカバー

### ビジネスロジックカバレッジ: 90%以上 🔵

- TTSServiceのすべてのメソッドが少なくとも1回はテストされる
- すべての状態遷移パターンがテストされる
- すべてのエラーケースがテストされる

---

## 次のステップ 🔵

### 推奨コマンド

次は `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

### Redフェーズで実装すること

1. **テストファイルの作成**:
   - `test/features/tts/providers/tts_provider_test.dart`
   - `test/features/tts/domain/services/tts_service_test.dart`

2. **モッククラスの作成**:
   - `test/mocks/mock_flutter_tts.dart`

3. **失敗するテストの実装**:
   - 上記のテストケース（TC-048-001〜029）をすべて実装
   - 実装前のため、すべてのテストが失敗（Red状態）になることを確認

4. **テスト実行**:
   - `flutter test test/features/tts/`
   - すべてのテストが失敗することを確認

---

## 品質判定結果

### ✅ 高品質

- **テストケース分類**: 正常系（10件）・異常系（4件）・境界値（6件）・状態管理（2件）・パフォーマンス（1件）・プラットフォーム（1件）・モック（2件）・エッジケース（2件）・リソース管理（1件）が網羅されている
- **期待値定義**: 各テストケースの期待値が明確に定義されている
- **技術選択**: Dart (Flutter 3.38.1) + flutter_test + mocktail が確定
- **実装可能性**: 既存のテストパターン（input_buffer_provider_test.dart、emergency_audio_service_test.dart）を踏襲しており、現在の技術スタックで実現可能
- **要件網羅率**: REQ-401, REQ-403, REQ-404, NFR-001, NFR-301, EDGE-004, EDGE-202をすべてカバー（90%以上）
- **信頼性レベル**: 🔵（青信号）が23件、🟡（黄信号）が6件、🔴（赤信号）が0件

### 改善点

- **実機テストの必要性**: TC-048-023（パフォーマンス）、TC-048-024（プラットフォーム互換性）、TC-048-027（音量チェック）は実機での統合テストが必要
- **checkVolume()の実装詳細**: プラットフォーム固有のAPIに依存するため、実装時に詳細を確認

---

## 更新履歴

- **2025-11-25**: テストケース定義書作成
  - 正常系（10件）、異常系（4件）、境界値（6件）、状態管理（2件）、パフォーマンス（1件）、プラットフォーム（1件）、モック（2件）、エッジケース（2件）、リソース管理（1件）の計29件のテストケースを定義
  - requirements.md、interfaces.dart、dataflow.md、既存テストパターンを参照
  - Given-When-Then パターンと日本語コメント指針を明記
  - 受け入れ基準との対応表を作成
  - 信頼性レベル（🔵🟡🔴）を各テストケースに明記
